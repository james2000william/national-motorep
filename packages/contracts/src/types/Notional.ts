/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export type BalanceActionStruct = {
  actionType: PromiseOrValue<BigNumberish>;
  currencyId: PromiseOrValue<BigNumberish>;
  depositActionAmount: PromiseOrValue<BigNumberish>;
  withdrawAmountInternalPrecision: PromiseOrValue<BigNumberish>;
  withdrawEntireCashBalance: PromiseOrValue<boolean>;
  redeemToUnderlying: PromiseOrValue<boolean>;
};

export type BalanceActionStructOutput = [
  number,
  number,
  BigNumber,
  BigNumber,
  boolean,
  boolean
] & {
  actionType: number;
  currencyId: number;
  depositActionAmount: BigNumber;
  withdrawAmountInternalPrecision: BigNumber;
  withdrawEntireCashBalance: boolean;
  redeemToUnderlying: boolean;
};

export type BalanceActionWithTradesStruct = {
  actionType: PromiseOrValue<BigNumberish>;
  currencyId: PromiseOrValue<BigNumberish>;
  depositActionAmount: PromiseOrValue<BigNumberish>;
  withdrawAmountInternalPrecision: PromiseOrValue<BigNumberish>;
  withdrawEntireCashBalance: PromiseOrValue<boolean>;
  redeemToUnderlying: PromiseOrValue<boolean>;
  trades: PromiseOrValue<BytesLike>[];
};

export type BalanceActionWithTradesStructOutput = [
  number,
  number,
  BigNumber,
  BigNumber,
  boolean,
  boolean,
  string[]
] & {
  actionType: number;
  currencyId: number;
  depositActionAmount: BigNumber;
  withdrawAmountInternalPrecision: BigNumber;
  withdrawEntireCashBalance: boolean;
  redeemToUnderlying: boolean;
  trades: string[];
};

export type BatchLendStruct = {
  currencyId: PromiseOrValue<BigNumberish>;
  depositUnderlying: PromiseOrValue<boolean>;
  trades: PromiseOrValue<BytesLike>[];
};

export type BatchLendStructOutput = [number, boolean, string[]] & {
  currencyId: number;
  depositUnderlying: boolean;
  trades: string[];
};

export type PortfolioAssetStruct = {
  currencyId: PromiseOrValue<BigNumberish>;
  maturity: PromiseOrValue<BigNumberish>;
  assetType: PromiseOrValue<BigNumberish>;
  notional: PromiseOrValue<BigNumberish>;
  storageSlot: PromiseOrValue<BigNumberish>;
  storageState: PromiseOrValue<BigNumberish>;
};

export type PortfolioAssetStructOutput = [
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  number
] & {
  currencyId: BigNumber;
  maturity: BigNumber;
  assetType: BigNumber;
  notional: BigNumber;
  storageSlot: BigNumber;
  storageState: number;
};

export type CashGroupSettingsStruct = {
  maxMarketIndex: PromiseOrValue<BigNumberish>;
  rateOracleTimeWindow5Min: PromiseOrValue<BigNumberish>;
  totalFeeBPS: PromiseOrValue<BigNumberish>;
  reserveFeeShare: PromiseOrValue<BigNumberish>;
  debtBuffer5BPS: PromiseOrValue<BigNumberish>;
  fCashHaircut5BPS: PromiseOrValue<BigNumberish>;
  settlementPenaltyRate5BPS: PromiseOrValue<BigNumberish>;
  liquidationfCashHaircut5BPS: PromiseOrValue<BigNumberish>;
  liquidationDebtBuffer5BPS: PromiseOrValue<BigNumberish>;
  liquidityTokenHaircuts: PromiseOrValue<BigNumberish>[];
  rateScalars: PromiseOrValue<BigNumberish>[];
};

export type CashGroupSettingsStructOutput = [
  number,
  number,
  number,
  number,
  number,
  number,
  number,
  number,
  number,
  number[],
  number[]
] & {
  maxMarketIndex: number;
  rateOracleTimeWindow5Min: number;
  totalFeeBPS: number;
  reserveFeeShare: number;
  debtBuffer5BPS: number;
  fCashHaircut5BPS: number;
  settlementPenaltyRate5BPS: number;
  liquidationfCashHaircut5BPS: number;
  liquidationDebtBuffer5BPS: number;
  liquidityTokenHaircuts: number[];
  rateScalars: number[];
};

export type AccountContextStruct = {
  nextSettleTime: PromiseOrValue<BigNumberish>;
  hasDebt: PromiseOrValue<BytesLike>;
  assetArrayLength: PromiseOrValue<BigNumberish>;
  bitmapCurrencyId: PromiseOrValue<BigNumberish>;
  activeCurrencies: PromiseOrValue<BytesLike>;
};

export type AccountContextStructOutput = [
  number,
  string,
  number,
  number,
  string
] & {
  nextSettleTime: number;
  hasDebt: string;
  assetArrayLength: number;
  bitmapCurrencyId: number;
  activeCurrencies: string;
};

export type AccountBalanceStruct = {
  currencyId: PromiseOrValue<BigNumberish>;
  cashBalance: PromiseOrValue<BigNumberish>;
  nTokenBalance: PromiseOrValue<BigNumberish>;
  lastClaimTime: PromiseOrValue<BigNumberish>;
  accountIncentiveDebt: PromiseOrValue<BigNumberish>;
};

export type AccountBalanceStructOutput = [
  number,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber
] & {
  currencyId: number;
  cashBalance: BigNumber;
  nTokenBalance: BigNumber;
  lastClaimTime: BigNumber;
  accountIncentiveDebt: BigNumber;
};

export type MarketParametersStruct = {
  storageSlot: PromiseOrValue<BytesLike>;
  maturity: PromiseOrValue<BigNumberish>;
  totalfCash: PromiseOrValue<BigNumberish>;
  totalAssetCash: PromiseOrValue<BigNumberish>;
  totalLiquidity: PromiseOrValue<BigNumberish>;
  lastImpliedRate: PromiseOrValue<BigNumberish>;
  oracleRate: PromiseOrValue<BigNumberish>;
  previousTradeTime: PromiseOrValue<BigNumberish>;
};

export type MarketParametersStructOutput = [
  string,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber
] & {
  storageSlot: string;
  maturity: BigNumber;
  totalfCash: BigNumber;
  totalAssetCash: BigNumber;
  totalLiquidity: BigNumber;
  lastImpliedRate: BigNumber;
  oracleRate: BigNumber;
  previousTradeTime: BigNumber;
};

export type AssetRateParametersStruct = {
  rateOracle: PromiseOrValue<string>;
  rate: PromiseOrValue<BigNumberish>;
  underlyingDecimals: PromiseOrValue<BigNumberish>;
};

export type AssetRateParametersStructOutput = [string, BigNumber, BigNumber] & {
  rateOracle: string;
  rate: BigNumber;
  underlyingDecimals: BigNumber;
};

export type TokenStruct = {
  tokenAddress: PromiseOrValue<string>;
  hasTransferFee: PromiseOrValue<boolean>;
  decimals: PromiseOrValue<BigNumberish>;
  tokenType: PromiseOrValue<BigNumberish>;
  maxCollateralBalance: PromiseOrValue<BigNumberish>;
};

export type TokenStructOutput = [
  string,
  boolean,
  BigNumber,
  number,
  BigNumber
] & {
  tokenAddress: string;
  hasTransferFee: boolean;
  decimals: BigNumber;
  tokenType: number;
  maxCollateralBalance: BigNumber;
};

export type ETHRateStruct = {
  rateDecimals: PromiseOrValue<BigNumberish>;
  rate: PromiseOrValue<BigNumberish>;
  buffer: PromiseOrValue<BigNumberish>;
  haircut: PromiseOrValue<BigNumberish>;
  liquidationDiscount: PromiseOrValue<BigNumberish>;
};

export type ETHRateStructOutput = [
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber
] & {
  rateDecimals: BigNumber;
  rate: BigNumber;
  buffer: BigNumber;
  haircut: BigNumber;
  liquidationDiscount: BigNumber;
};

export type ETHRateStorageStruct = {
  rateOracle: PromiseOrValue<string>;
  rateDecimalPlaces: PromiseOrValue<BigNumberish>;
  mustInvert: PromiseOrValue<boolean>;
  buffer: PromiseOrValue<BigNumberish>;
  haircut: PromiseOrValue<BigNumberish>;
  liquidationDiscount: PromiseOrValue<BigNumberish>;
};

export type ETHRateStorageStructOutput = [
  string,
  number,
  boolean,
  number,
  number,
  number
] & {
  rateOracle: string;
  rateDecimalPlaces: number;
  mustInvert: boolean;
  buffer: number;
  haircut: number;
  liquidationDiscount: number;
};

export type AssetRateStorageStruct = {
  rateOracle: PromiseOrValue<string>;
  underlyingDecimalPlaces: PromiseOrValue<BigNumberish>;
};

export type AssetRateStorageStructOutput = [string, number] & {
  rateOracle: string;
  underlyingDecimalPlaces: number;
};

export type VaultAccountStruct = {
  fCash: PromiseOrValue<BigNumberish>;
  maturity: PromiseOrValue<BigNumberish>;
  vaultShares: PromiseOrValue<BigNumberish>;
  account: PromiseOrValue<string>;
  tempCashBalance: PromiseOrValue<BigNumberish>;
};

export type VaultAccountStructOutput = [
  BigNumber,
  BigNumber,
  BigNumber,
  string,
  BigNumber
] & {
  fCash: BigNumber;
  maturity: BigNumber;
  vaultShares: BigNumber;
  account: string;
  tempCashBalance: BigNumber;
};

export type VaultConfigStruct = {
  vault: PromiseOrValue<string>;
  flags: PromiseOrValue<BigNumberish>;
  borrowCurrencyId: PromiseOrValue<BigNumberish>;
  minAccountBorrowSize: PromiseOrValue<BigNumberish>;
  feeRate: PromiseOrValue<BigNumberish>;
  minCollateralRatio: PromiseOrValue<BigNumberish>;
  liquidationRate: PromiseOrValue<BigNumberish>;
  reserveFeeShare: PromiseOrValue<BigNumberish>;
  maxBorrowMarketIndex: PromiseOrValue<BigNumberish>;
  maxDeleverageCollateralRatio: PromiseOrValue<BigNumberish>;
  secondaryBorrowCurrencies: [
    PromiseOrValue<BigNumberish>,
    PromiseOrValue<BigNumberish>
  ];
  assetRate: AssetRateParametersStruct;
};

export type VaultConfigStructOutput = [
  string,
  number,
  number,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber,
  [number, number],
  AssetRateParametersStructOutput
] & {
  vault: string;
  flags: number;
  borrowCurrencyId: number;
  minAccountBorrowSize: BigNumber;
  feeRate: BigNumber;
  minCollateralRatio: BigNumber;
  liquidationRate: BigNumber;
  reserveFeeShare: BigNumber;
  maxBorrowMarketIndex: BigNumber;
  maxDeleverageCollateralRatio: BigNumber;
  secondaryBorrowCurrencies: [number, number];
  assetRate: AssetRateParametersStructOutput;
};

export type VaultStateStruct = {
  maturity: PromiseOrValue<BigNumberish>;
  totalfCash: PromiseOrValue<BigNumberish>;
  isSettled: PromiseOrValue<boolean>;
  totalVaultShares: PromiseOrValue<BigNumberish>;
  totalAssetCash: PromiseOrValue<BigNumberish>;
  totalStrategyTokens: PromiseOrValue<BigNumberish>;
  settlementStrategyTokenValue: PromiseOrValue<BigNumberish>;
};

export type VaultStateStructOutput = [
  BigNumber,
  BigNumber,
  boolean,
  BigNumber,
  BigNumber,
  BigNumber,
  BigNumber
] & {
  maturity: BigNumber;
  totalfCash: BigNumber;
  isSettled: boolean;
  totalVaultShares: BigNumber;
  totalAssetCash: BigNumber;
  totalStrategyTokens: BigNumber;
  settlementStrategyTokenValue: BigNumber;
};

export type TokenStorageStruct = {
  tokenAddress: PromiseOrValue<string>;
  hasTransferFee: PromiseOrValue<boolean>;
  tokenType: PromiseOrValue<BigNumberish>;
  decimalPlaces: PromiseOrValue<BigNumberish>;
  maxCollateralBalance: PromiseOrValue<BigNumberish>;
};

export type TokenStorageStructOutput = [
  string,
  boolean,
  number,
  number,
  BigNumber
] & {
  tokenAddress: string;
  hasTransferFee: boolean;
  tokenType: number;
  decimalPlaces: number;
  maxCollateralBalance: BigNumber;
};

export type VaultConfigStorageStruct = {
  flags: PromiseOrValue<BigNumberish>;
  borrowCurrencyId: PromiseOrValue<BigNumberish>;
  minAccountBorrowSize: PromiseOrValue<BigNumberish>;
  minCollateralRatioBPS: PromiseOrValue<BigNumberish>;
  feeRate5BPS: PromiseOrValue<BigNumberish>;
  liquidationRate: PromiseOrValue<BigNumberish>;
  reserveFeeShare: PromiseOrValue<BigNumberish>;
  maxBorrowMarketIndex: PromiseOrValue<BigNumberish>;
  maxDeleverageCollateralRatioBPS: PromiseOrValue<BigNumberish>;
  secondaryBorrowCurrencies: [
    PromiseOrValue<BigNumberish>,
    PromiseOrValue<BigNumberish>
  ];
};

export type VaultConfigStorageStructOutput = [
  number,
  number,
  number,
  number,
  number,
  number,
  number,
  number,
  number,
  [number, number]
] & {
  flags: number;
  borrowCurrencyId: number;
  minAccountBorrowSize: number;
  minCollateralRatioBPS: number;
  feeRate5BPS: number;
  liquidationRate: number;
  reserveFeeShare: number;
  maxBorrowMarketIndex: number;
  maxDeleverageCollateralRatioBPS: number;
  secondaryBorrowCurrencies: [number, number];
};

export interface NotionalInterface extends utils.Interface {
  functions: {
    "balanceOf(address,uint256)": FunctionFragment;
    "balanceOfBatch(address[],uint256[])": FunctionFragment;
    "batchBalanceAction(address,(uint8,uint16,uint256,uint256,bool,bool)[])": FunctionFragment;
    "batchBalanceAndTradeAction(address,(uint8,uint16,uint256,uint256,bool,bool,bytes32[])[])": FunctionFragment;
    "batchBalanceAndTradeActionWithCallback(address,(uint8,uint16,uint256,uint256,bool,bool,bytes32[])[],bytes)": FunctionFragment;
    "batchLend(address,(uint16,bool,bytes32[])[])": FunctionFragment;
    "borrowSecondaryCurrencyToVault(address,uint256,uint256[2],uint32[2],uint32[2])": FunctionFragment;
    "calculateCollateralCurrencyLiquidation(address,uint16,uint16,uint128,uint96)": FunctionFragment;
    "calculateLocalCurrencyLiquidation(address,uint16,uint96)": FunctionFragment;
    "calculateNTokensToMint(uint16,uint88)": FunctionFragment;
    "calculatefCashCrossCurrencyLiquidation(address,uint16,uint16,uint256[],uint256[])": FunctionFragment;
    "calculatefCashLocalLiquidation(address,uint16,uint256[],uint256[])": FunctionFragment;
    "claimCOMPAndTransfer(address[])": FunctionFragment;
    "claimOwnership()": FunctionFragment;
    "convertCashBalanceToExternal(uint16,int256,bool)": FunctionFragment;
    "decodeToAssets(uint256[],uint256[])": FunctionFragment;
    "deleverageAccount(address,address,address,uint256,bool,bytes)": FunctionFragment;
    "depositAssetToken(address,uint16,uint256)": FunctionFragment;
    "depositUnderlyingToken(address,uint16,uint256)": FunctionFragment;
    "depositVaultCashToStrategyTokens(uint256,uint256,bytes)": FunctionFragment;
    "enableBitmapCurrency(uint16)": FunctionFragment;
    "enableCashGroup(uint16,address,(uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8[],uint8[]),string,string)": FunctionFragment;
    "encodeToId(uint16,uint40,uint8)": FunctionFragment;
    "enterVault(address,address,uint256,uint256,uint256,uint32,bytes)": FunctionFragment;
    "exitVault(address,address,address,uint256,uint256,uint32,bytes)": FunctionFragment;
    "getAccount(address)": FunctionFragment;
    "getAccountBalance(uint16,address)": FunctionFragment;
    "getAccountContext(address)": FunctionFragment;
    "getAccountPortfolio(address)": FunctionFragment;
    "getActiveMarkets(uint16)": FunctionFragment;
    "getActiveMarketsAtBlockTime(uint16,uint32)": FunctionFragment;
    "getAssetsBitmap(address,uint16)": FunctionFragment;
    "getAuthorizedCallbackContractStatus(address)": FunctionFragment;
    "getBorrowCapacity(address,uint16)": FunctionFragment;
    "getCashAmountGivenfCashAmount(uint16,int88,uint256,uint256)": FunctionFragment;
    "getCashGroup(uint16)": FunctionFragment;
    "getCashGroupAndAssetRate(uint16)": FunctionFragment;
    "getCashRequiredToSettle(address,uint256)": FunctionFragment;
    "getCurrency(uint16)": FunctionFragment;
    "getCurrencyAndRates(uint16)": FunctionFragment;
    "getCurrencyId(address)": FunctionFragment;
    "getDepositFromfCashLend(uint16,uint256,uint256,uint32,uint256)": FunctionFragment;
    "getDepositParameters(uint16)": FunctionFragment;
    "getFreeCollateral(address)": FunctionFragment;
    "getGlobalTransferOperatorStatus(address)": FunctionFragment;
    "getImplementation()": FunctionFragment;
    "getInitializationParameters(uint16)": FunctionFragment;
    "getLendingPool()": FunctionFragment;
    "getMarket(uint16,uint256,uint256)": FunctionFragment;
    "getMarketIndex(uint256,uint256)": FunctionFragment;
    "getMaxCurrencyId()": FunctionFragment;
    "getNTokenAccount(address)": FunctionFragment;
    "getNTokenPortfolio(address)": FunctionFragment;
    "getNoteToken()": FunctionFragment;
    "getOwnershipStatus()": FunctionFragment;
    "getPresentfCashValue(uint16,uint256,int256,uint256,bool)": FunctionFragment;
    "getPrincipalFromfCashBorrow(uint16,uint256,uint256,uint32,uint256)": FunctionFragment;
    "getRateStorage(uint16)": FunctionFragment;
    "getReserveBalance(uint16)": FunctionFragment;
    "getReserveBuffer(uint16)": FunctionFragment;
    "getSecondaryBorrow(address,uint16,uint256)": FunctionFragment;
    "getSecondaryIncentiveRewarder(uint16)": FunctionFragment;
    "getSettlementRate(uint16,uint40)": FunctionFragment;
    "getTreasuryManager()": FunctionFragment;
    "getVaultAccount(address,address)": FunctionFragment;
    "getVaultAccountCollateralRatio(address,address)": FunctionFragment;
    "getVaultAccountDebtShares(address,address)": FunctionFragment;
    "getVaultConfig(address)": FunctionFragment;
    "getVaultState(address,uint256)": FunctionFragment;
    "getfCashAmountGivenCashAmount(uint16,int88,uint256,uint256)": FunctionFragment;
    "getfCashBorrowFromPrincipal(uint16,uint256,uint256,uint32,uint256,bool)": FunctionFragment;
    "getfCashLendFromDeposit(uint16,uint256,uint256,uint32,uint256,bool)": FunctionFragment;
    "getfCashNotional(address,uint16,uint256)": FunctionFragment;
    "initializeMarkets(uint16,bool)": FunctionFragment;
    "initiateSecondaryBorrowSettlement(uint256)": FunctionFragment;
    "isApprovedForAll(address,address)": FunctionFragment;
    "liquidateCollateralCurrency(address,uint16,uint16,uint128,uint96,bool,bool)": FunctionFragment;
    "liquidateLocalCurrency(address,uint16,uint96)": FunctionFragment;
    "liquidatefCashCrossCurrency(address,uint16,uint16,uint256[],uint256[])": FunctionFragment;
    "liquidatefCashLocal(address,uint16,uint256[],uint256[])": FunctionFragment;
    "listCurrency((address,bool,uint8,uint8,uint72),(address,bool,uint8,uint8,uint72),address,bool,uint8,uint8,uint8)": FunctionFragment;
    "nTokenAddress(uint16)": FunctionFragment;
    "nTokenBalanceOf(uint16,address)": FunctionFragment;
    "nTokenClaimIncentives()": FunctionFragment;
    "nTokenGetClaimableIncentives(address,uint256)": FunctionFragment;
    "nTokenPresentValueAssetDenominated(uint16)": FunctionFragment;
    "nTokenPresentValueUnderlyingDenominated(uint16)": FunctionFragment;
    "nTokenRedeem(address,uint16,uint96,bool,bool)": FunctionFragment;
    "nTokenTotalSupply(address)": FunctionFragment;
    "nTokenTransfer(uint16,address,address,uint256)": FunctionFragment;
    "nTokenTransferAllowance(uint16,address,address)": FunctionFragment;
    "nTokenTransferApprove(uint16,address,address,uint256)": FunctionFragment;
    "nTokenTransferApproveAll(address,uint256)": FunctionFragment;
    "nTokenTransferFrom(uint16,address,address,address,uint256)": FunctionFragment;
    "owner()": FunctionFragment;
    "pauseGuardian()": FunctionFragment;
    "pauseRouter()": FunctionFragment;
    "redeemStrategyTokensToCash(uint256,uint256,bytes)": FunctionFragment;
    "reduceMaxBorrowCapacity(address,uint80,uint256,uint256,bytes)": FunctionFragment;
    "repaySecondaryCurrencyFromVault(address,uint16,uint256,uint256,uint32,bytes)": FunctionFragment;
    "rollVaultPosition(address,address,uint256,uint256,uint256,uint32,uint32,bytes)": FunctionFragment;
    "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)": FunctionFragment;
    "safeTransferFrom(address,address,uint256,uint256,bytes)": FunctionFragment;
    "setApprovalForAll(address,bool)": FunctionFragment;
    "setLendingPool(address)": FunctionFragment;
    "setMaxBorrowCapacity(address,uint80)": FunctionFragment;
    "setPauseRouterAndGuardian(address,address)": FunctionFragment;
    "setReserveBuffer(uint16,uint256)": FunctionFragment;
    "setReserveCashBalance(uint16,int256)": FunctionFragment;
    "setSecondaryIncentiveRewarder(uint16,address)": FunctionFragment;
    "setTreasuryManager(address)": FunctionFragment;
    "setVaultPauseStatus(address,bool)": FunctionFragment;
    "settleAccount(address)": FunctionFragment;
    "settleVault(address,uint256)": FunctionFragment;
    "signedBalanceOf(address,uint256)": FunctionFragment;
    "signedBalanceOfBatch(address[],uint256[])": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "sweepCashIntoMarkets(uint16)": FunctionFragment;
    "transferOwnership(address,bool)": FunctionFragment;
    "transferReserveToTreasury(uint16[])": FunctionFragment;
    "updateAssetRate(uint16,address)": FunctionFragment;
    "updateAuthorizedCallbackContract(address,bool)": FunctionFragment;
    "updateCashGroup(uint16,(uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8[],uint8[]))": FunctionFragment;
    "updateDepositParameters(uint16,uint32[],uint32[])": FunctionFragment;
    "updateETHRate(uint16,address,bool,uint8,uint8,uint8)": FunctionFragment;
    "updateGlobalTransferOperator(address,bool)": FunctionFragment;
    "updateIncentiveEmissionRate(uint16,uint32)": FunctionFragment;
    "updateInitializationParameters(uint16,uint32[],uint32[])": FunctionFragment;
    "updateMaxCollateralBalance(uint16,uint72)": FunctionFragment;
    "updateSecondaryBorrowCapacity(address,uint16,uint80)": FunctionFragment;
    "updateTokenCollateralParameters(uint16,uint8,uint8,uint8,uint8,uint8)": FunctionFragment;
    "updateVault(address,(uint16,uint16,uint32,uint16,uint8,uint8,uint8,uint8,uint16,uint16[2]),uint80)": FunctionFragment;
    "upgradeTo(address)": FunctionFragment;
    "upgradeToAndCall(address,bytes)": FunctionFragment;
    "withdraw(uint16,uint88,bool)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "balanceOf"
      | "balanceOfBatch"
      | "batchBalanceAction"
      | "batchBalanceAndTradeAction"
      | "batchBalanceAndTradeActionWithCallback"
      | "batchLend"
      | "borrowSecondaryCurrencyToVault"
      | "calculateCollateralCurrencyLiquidation"
      | "calculateLocalCurrencyLiquidation"
      | "calculateNTokensToMint"
      | "calculatefCashCrossCurrencyLiquidation"
      | "calculatefCashLocalLiquidation"
      | "claimCOMPAndTransfer"
      | "claimOwnership"
      | "convertCashBalanceToExternal"
      | "decodeToAssets"
      | "deleverageAccount"
      | "depositAssetToken"
      | "depositUnderlyingToken"
      | "depositVaultCashToStrategyTokens"
      | "enableBitmapCurrency"
      | "enableCashGroup"
      | "encodeToId"
      | "enterVault"
      | "exitVault"
      | "getAccount"
      | "getAccountBalance"
      | "getAccountContext"
      | "getAccountPortfolio"
      | "getActiveMarkets"
      | "getActiveMarketsAtBlockTime"
      | "getAssetsBitmap"
      | "getAuthorizedCallbackContractStatus"
      | "getBorrowCapacity"
      | "getCashAmountGivenfCashAmount"
      | "getCashGroup"
      | "getCashGroupAndAssetRate"
      | "getCashRequiredToSettle"
      | "getCurrency"
      | "getCurrencyAndRates"
      | "getCurrencyId"
      | "getDepositFromfCashLend"
      | "getDepositParameters"
      | "getFreeCollateral"
      | "getGlobalTransferOperatorStatus"
      | "getImplementation"
      | "getInitializationParameters"
      | "getLendingPool"
      | "getMarket"
      | "getMarketIndex"
      | "getMaxCurrencyId"
      | "getNTokenAccount"
      | "getNTokenPortfolio"
      | "getNoteToken"
      | "getOwnershipStatus"
      | "getPresentfCashValue"
      | "getPrincipalFromfCashBorrow"
      | "getRateStorage"
      | "getReserveBalance"
      | "getReserveBuffer"
      | "getSecondaryBorrow"
      | "getSecondaryIncentiveRewarder"
      | "getSettlementRate"
      | "getTreasuryManager"
      | "getVaultAccount"
      | "getVaultAccountCollateralRatio"
      | "getVaultAccountDebtShares"
      | "getVaultConfig"
      | "getVaultState"
      | "getfCashAmountGivenCashAmount"
      | "getfCashBorrowFromPrincipal"
      | "getfCashLendFromDeposit"
      | "getfCashNotional"
      | "initializeMarkets"
      | "initiateSecondaryBorrowSettlement"
      | "isApprovedForAll"
      | "liquidateCollateralCurrency"
      | "liquidateLocalCurrency"
      | "liquidatefCashCrossCurrency"
      | "liquidatefCashLocal"
      | "listCurrency"
      | "nTokenAddress"
      | "nTokenBalanceOf"
      | "nTokenClaimIncentives"
      | "nTokenGetClaimableIncentives"
      | "nTokenPresentValueAssetDenominated"
      | "nTokenPresentValueUnderlyingDenominated"
      | "nTokenRedeem"
      | "nTokenTotalSupply"
      | "nTokenTransfer"
      | "nTokenTransferAllowance"
      | "nTokenTransferApprove"
      | "nTokenTransferApproveAll"
      | "nTokenTransferFrom"
      | "owner"
      | "pauseGuardian"
      | "pauseRouter"
      | "redeemStrategyTokensToCash"
      | "reduceMaxBorrowCapacity"
      | "repaySecondaryCurrencyFromVault"
      | "rollVaultPosition"
      | "safeBatchTransferFrom"
      | "safeTransferFrom"
      | "setApprovalForAll"
      | "setLendingPool"
      | "setMaxBorrowCapacity"
      | "setPauseRouterAndGuardian"
      | "setReserveBuffer"
      | "setReserveCashBalance"
      | "setSecondaryIncentiveRewarder"
      | "setTreasuryManager"
      | "setVaultPauseStatus"
      | "settleAccount"
      | "settleVault"
      | "signedBalanceOf"
      | "signedBalanceOfBatch"
      | "supportsInterface"
      | "sweepCashIntoMarkets"
      | "transferOwnership"
      | "transferReserveToTreasury"
      | "updateAssetRate"
      | "updateAuthorizedCallbackContract"
      | "updateCashGroup"
      | "updateDepositParameters"
      | "updateETHRate"
      | "updateGlobalTransferOperator"
      | "updateIncentiveEmissionRate"
      | "updateInitializationParameters"
      | "updateMaxCollateralBalance"
      | "updateSecondaryBorrowCapacity"
      | "updateTokenCollateralParameters"
      | "updateVault"
      | "upgradeTo"
      | "upgradeToAndCall"
      | "withdraw"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOfBatch",
    values: [PromiseOrValue<string>[], PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchBalanceAction",
    values: [PromiseOrValue<string>, BalanceActionStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchBalanceAndTradeAction",
    values: [PromiseOrValue<string>, BalanceActionWithTradesStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchBalanceAndTradeActionWithCallback",
    values: [
      PromiseOrValue<string>,
      BalanceActionWithTradesStruct[],
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchLend",
    values: [PromiseOrValue<string>, BatchLendStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "borrowSecondaryCurrencyToVault",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateCollateralCurrencyLiquidation",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateLocalCurrencyLiquidation",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateNTokensToMint",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "calculatefCashCrossCurrencyLiquidation",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "calculatefCashLocalLiquidation",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "claimCOMPAndTransfer",
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "claimOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "convertCashBalanceToExternal",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "decodeToAssets",
    values: [PromiseOrValue<BigNumberish>[], PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "deleverageAccount",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositAssetToken",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositUnderlyingToken",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositVaultCashToStrategyTokens",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "enableBitmapCurrency",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "enableCashGroup",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      CashGroupSettingsStruct,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "encodeToId",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "enterVault",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "exitVault",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getAccount",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAccountBalance",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAccountContext",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAccountPortfolio",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getActiveMarkets",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getActiveMarketsAtBlockTime",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAssetsBitmap",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAuthorizedCallbackContractStatus",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getBorrowCapacity",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getCashAmountGivenfCashAmount",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getCashGroup",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getCashGroupAndAssetRate",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getCashRequiredToSettle",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getCurrency",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getCurrencyAndRates",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getCurrencyId",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getDepositFromfCashLend",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getDepositParameters",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getFreeCollateral",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getGlobalTransferOperatorStatus",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getImplementation",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getInitializationParameters",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getLendingPool",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getMarket",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getMarketIndex",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getMaxCurrencyId",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getNTokenAccount",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNTokenPortfolio",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNoteToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getOwnershipStatus",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getPresentfCashValue",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getPrincipalFromfCashBorrow",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getRateStorage",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveBalance",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveBuffer",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getSecondaryBorrow",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getSecondaryIncentiveRewarder",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getSettlementRate",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getTreasuryManager",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getVaultAccount",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getVaultAccountCollateralRatio",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getVaultAccountDebtShares",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getVaultConfig",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getVaultState",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getfCashAmountGivenCashAmount",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getfCashBorrowFromPrincipal",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getfCashLendFromDeposit",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getfCashNotional",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "initializeMarkets",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "initiateSecondaryBorrowSettlement",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "isApprovedForAll",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidateCollateralCurrency",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidateLocalCurrency",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidatefCashCrossCurrency",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidatefCashLocal",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "listCurrency",
    values: [
      TokenStorageStruct,
      TokenStorageStruct,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "nTokenAddress",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "nTokenBalanceOf",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "nTokenClaimIncentives",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nTokenGetClaimableIncentives",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "nTokenPresentValueAssetDenominated",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "nTokenPresentValueUnderlyingDenominated",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "nTokenRedeem",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "nTokenTotalSupply",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "nTokenTransfer",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "nTokenTransferAllowance",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "nTokenTransferApprove",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "nTokenTransferApproveAll",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "nTokenTransferFrom",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "pauseGuardian",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "pauseRouter",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "redeemStrategyTokensToCash",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "reduceMaxBorrowCapacity",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "repaySecondaryCurrencyFromVault",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "rollVaultPosition",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "safeBatchTransferFrom",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "safeTransferFrom",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setApprovalForAll",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setLendingPool",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setMaxBorrowCapacity",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setPauseRouterAndGuardian",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setReserveBuffer",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setReserveCashBalance",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setSecondaryIncentiveRewarder",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setTreasuryManager",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setVaultPauseStatus",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "settleAccount",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "settleVault",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "signedBalanceOf",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "signedBalanceOfBatch",
    values: [PromiseOrValue<string>[], PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "sweepCashIntoMarkets",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "transferReserveToTreasury",
    values: [PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "updateAssetRate",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateAuthorizedCallbackContract",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateCashGroup",
    values: [PromiseOrValue<BigNumberish>, CashGroupSettingsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "updateDepositParameters",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateETHRate",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateGlobalTransferOperator",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateIncentiveEmissionRate",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateInitializationParameters",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateMaxCollateralBalance",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateSecondaryBorrowCapacity",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateTokenCollateralParameters",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateVault",
    values: [
      PromiseOrValue<string>,
      VaultConfigStorageStruct,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeTo",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeToAndCall",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;

  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "balanceOfBatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchBalanceAction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchBalanceAndTradeAction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchBalanceAndTradeActionWithCallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "batchLend", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "borrowSecondaryCurrencyToVault",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateCollateralCurrencyLiquidation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateLocalCurrencyLiquidation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateNTokensToMint",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculatefCashCrossCurrencyLiquidation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculatefCashLocalLiquidation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimCOMPAndTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "convertCashBalanceToExternal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "decodeToAssets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deleverageAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositAssetToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositUnderlyingToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositVaultCashToStrategyTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enableBitmapCurrency",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enableCashGroup",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "encodeToId", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "enterVault", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "exitVault", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getAccount", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getAccountBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAccountContext",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAccountPortfolio",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getActiveMarkets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getActiveMarketsAtBlockTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAssetsBitmap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAuthorizedCallbackContractStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBorrowCapacity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCashAmountGivenfCashAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCashGroup",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCashGroupAndAssetRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCashRequiredToSettle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCurrency",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCurrencyAndRates",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCurrencyId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDepositFromfCashLend",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDepositParameters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFreeCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getGlobalTransferOperatorStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getImplementation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getInitializationParameters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLendingPool",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getMarket", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getMarketIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMaxCurrencyId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNTokenAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNTokenPortfolio",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNoteToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getOwnershipStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPresentfCashValue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPrincipalFromfCashBorrow",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRateStorage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveBuffer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSecondaryBorrow",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSecondaryIncentiveRewarder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSettlementRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTreasuryManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getVaultAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getVaultAccountCollateralRatio",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getVaultAccountDebtShares",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getVaultConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getVaultState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getfCashAmountGivenCashAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getfCashBorrowFromPrincipal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getfCashLendFromDeposit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getfCashNotional",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initializeMarkets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initiateSecondaryBorrowSettlement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isApprovedForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidateCollateralCurrency",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidateLocalCurrency",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidatefCashCrossCurrency",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidatefCashLocal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "listCurrency",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nTokenAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nTokenBalanceOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nTokenClaimIncentives",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nTokenGetClaimableIncentives",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nTokenPresentValueAssetDenominated",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nTokenPresentValueUnderlyingDenominated",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nTokenRedeem",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nTokenTotalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nTokenTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nTokenTransferAllowance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nTokenTransferApprove",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nTokenTransferApproveAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nTokenTransferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pauseGuardian",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "pauseRouter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "redeemStrategyTokensToCash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "reduceMaxBorrowCapacity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "repaySecondaryCurrencyFromVault",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rollVaultPosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "safeBatchTransferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "safeTransferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setApprovalForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setLendingPool",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMaxBorrowCapacity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPauseRouterAndGuardian",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setReserveBuffer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setReserveCashBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setSecondaryIncentiveRewarder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTreasuryManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setVaultPauseStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "settleAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "settleVault",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "signedBalanceOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "signedBalanceOfBatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sweepCashIntoMarkets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferReserveToTreasury",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateAssetRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateAuthorizedCallbackContract",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateCashGroup",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateDepositParameters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateETHRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateGlobalTransferOperator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateIncentiveEmissionRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateInitializationParameters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateMaxCollateralBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateSecondaryBorrowCapacity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateTokenCollateralParameters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateVault",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "upgradeTo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "upgradeToAndCall",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;

  events: {
    "AccountContextUpdate(address)": EventFragment;
    "AccountSettled(address)": EventFragment;
    "AddRemoveLiquidity(address,uint16,uint40,int256,int256,int256)": EventFragment;
    "Approval(address,address,uint256)": EventFragment;
    "ApprovalForAll(address,address,bool)": EventFragment;
    "CashBalanceChange(address,uint16,int256)": EventFragment;
    "DeployNToken(uint16,address)": EventFragment;
    "ExcessReserveBalanceHarvested(uint16,int256)": EventFragment;
    "IncentivesMigrated(uint16,uint256,uint256,uint256)": EventFragment;
    "LendBorrowTrade(address,uint16,uint40,int256,int256)": EventFragment;
    "LiquidateCollateralCurrency(address,address,uint16,uint16,int256,int256,int256)": EventFragment;
    "LiquidateLocalCurrency(address,address,uint16,int256)": EventFragment;
    "LiquidatefCashEvent(address,address,uint16,uint16,int256,uint256[],int256[])": EventFragment;
    "ListCurrency(uint16)": EventFragment;
    "MarketsInitialized(uint16)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "PauseRouterAndGuardianUpdated(address,address)": EventFragment;
    "ProtocolInsolvency(address,uint16,uint256,int256)": EventFragment;
    "ReserveBalanceUpdated(uint16,int256)": EventFragment;
    "ReserveBufferUpdated(uint16,uint256)": EventFragment;
    "ReserveFeeAccrued(uint16,int256)": EventFragment;
    "SetSettlementRate(uint256,uint256,uint128)": EventFragment;
    "SettledCashDebt(address,uint16,address,int256,int256)": EventFragment;
    "SweepCashIntoMarkets(uint16,int256)": EventFragment;
    "Transfer(address,address,uint256)": EventFragment;
    "TransferBatch(address,address,address,uint256[],uint256[])": EventFragment;
    "TransferSingle(address,address,address,uint256,uint256)": EventFragment;
    "TreasuryManagerChanged(address,address)": EventFragment;
    "URI(string,uint256)": EventFragment;
    "UpdateAssetRate(uint16)": EventFragment;
    "UpdateAuthorizedCallbackContract(address,bool)": EventFragment;
    "UpdateCashGroup(uint16)": EventFragment;
    "UpdateDepositParameters(uint16)": EventFragment;
    "UpdateETHRate(uint16)": EventFragment;
    "UpdateGlobalTransferOperator(address,bool)": EventFragment;
    "UpdateIncentiveEmissionRate(uint16,uint32)": EventFragment;
    "UpdateInitializationParameters(uint16)": EventFragment;
    "UpdateLendingPool(address)": EventFragment;
    "UpdateMaxCollateralBalance(uint16,uint72)": EventFragment;
    "UpdateSecondaryIncentiveRewarder(uint16,address)": EventFragment;
    "UpdateTokenCollateralParameters(uint16)": EventFragment;
    "VaultBorrowCapacityChange(address,uint16,uint256)": EventFragment;
    "VaultDeleverageAccount(address,address,uint256,int256)": EventFragment;
    "VaultEnterMaturity(address,uint256,address,uint256,uint256,uint256)": EventFragment;
    "VaultEnterPosition(address,address,uint256,uint256)": EventFragment;
    "VaultExitPostMaturity(address,address,uint256,uint256)": EventFragment;
    "VaultExitPreMaturity(address,address,uint256,uint256,uint256,uint256)": EventFragment;
    "VaultFeeAccrued(address,uint16,uint256,int256,int256)": EventFragment;
    "VaultLiquidatorProfit(address,address,address,uint256,bool)": EventFragment;
    "VaultMintStrategyToken(address,uint256,uint256,uint256)": EventFragment;
    "VaultPauseStatus(address,bool)": EventFragment;
    "VaultRedeemStrategyToken(address,uint256,int256,uint256)": EventFragment;
    "VaultRepaySecondaryBorrow(address,address,uint16,uint256,uint256,uint256)": EventFragment;
    "VaultRollPosition(address,address,uint256,uint256)": EventFragment;
    "VaultSecondaryBorrow(address,address,uint16,uint256,uint256,uint256)": EventFragment;
    "VaultSecondaryBorrowSnapshot(address,uint16,uint256,int256,int256)": EventFragment;
    "VaultSettled(address,uint256,int256,uint256,uint256,uint256,int256)": EventFragment;
    "VaultSettledAssetsRemaining(address,uint256,int256,uint256)": EventFragment;
    "VaultShortfall(address,uint16,uint256,int256)": EventFragment;
    "VaultStateUpdate(address,uint256,int256,uint256,uint256,uint256)": EventFragment;
    "VaultUpdateSecondaryBorrowCapacity(address,uint16,uint80)": EventFragment;
    "VaultUpdated(address,bool,uint80)": EventFragment;
    "nTokenResidualPurchase(uint16,uint40,address,int256,int256)": EventFragment;
    "nTokenSupplyChange(address,uint16,int256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AccountContextUpdate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AccountSettled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AddRemoveLiquidity"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ApprovalForAll"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CashBalanceChange"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DeployNToken"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "ExcessReserveBalanceHarvested"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "IncentivesMigrated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LendBorrowTrade"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "LiquidateCollateralCurrency"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LiquidateLocalCurrency"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LiquidatefCashEvent"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ListCurrency"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MarketsInitialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "PauseRouterAndGuardianUpdated"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProtocolInsolvency"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ReserveBalanceUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ReserveBufferUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ReserveFeeAccrued"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetSettlementRate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SettledCashDebt"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SweepCashIntoMarkets"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransferBatch"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransferSingle"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TreasuryManagerChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "URI"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdateAssetRate"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "UpdateAuthorizedCallbackContract"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdateCashGroup"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdateDepositParameters"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdateETHRate"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "UpdateGlobalTransferOperator"
  ): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "UpdateIncentiveEmissionRate"
  ): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "UpdateInitializationParameters"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdateLendingPool"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdateMaxCollateralBalance"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "UpdateSecondaryIncentiveRewarder"
  ): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "UpdateTokenCollateralParameters"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VaultBorrowCapacityChange"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VaultDeleverageAccount"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VaultEnterMaturity"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VaultEnterPosition"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VaultExitPostMaturity"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VaultExitPreMaturity"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VaultFeeAccrued"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VaultLiquidatorProfit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VaultMintStrategyToken"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VaultPauseStatus"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VaultRedeemStrategyToken"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VaultRepaySecondaryBorrow"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VaultRollPosition"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VaultSecondaryBorrow"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "VaultSecondaryBorrowSnapshot"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VaultSettled"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "VaultSettledAssetsRemaining"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VaultShortfall"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VaultStateUpdate"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "VaultUpdateSecondaryBorrowCapacity"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VaultUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "nTokenResidualPurchase"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "nTokenSupplyChange"): EventFragment;
}

export interface AccountContextUpdateEventObject {
  account: string;
}
export type AccountContextUpdateEvent = TypedEvent<
  [string],
  AccountContextUpdateEventObject
>;

export type AccountContextUpdateEventFilter =
  TypedEventFilter<AccountContextUpdateEvent>;

export interface AccountSettledEventObject {
  account: string;
}
export type AccountSettledEvent = TypedEvent<
  [string],
  AccountSettledEventObject
>;

export type AccountSettledEventFilter = TypedEventFilter<AccountSettledEvent>;

export interface AddRemoveLiquidityEventObject {
  account: string;
  currencyId: number;
  maturity: number;
  netAssetCash: BigNumber;
  netfCash: BigNumber;
  netLiquidityTokens: BigNumber;
}
export type AddRemoveLiquidityEvent = TypedEvent<
  [string, number, number, BigNumber, BigNumber, BigNumber],
  AddRemoveLiquidityEventObject
>;

export type AddRemoveLiquidityEventFilter =
  TypedEventFilter<AddRemoveLiquidityEvent>;

export interface ApprovalEventObject {
  owner: string;
  spender: string;
  amount: BigNumber;
}
export type ApprovalEvent = TypedEvent<
  [string, string, BigNumber],
  ApprovalEventObject
>;

export type ApprovalEventFilter = TypedEventFilter<ApprovalEvent>;

export interface ApprovalForAllEventObject {
  account: string;
  operator: string;
  approved: boolean;
}
export type ApprovalForAllEvent = TypedEvent<
  [string, string, boolean],
  ApprovalForAllEventObject
>;

export type ApprovalForAllEventFilter = TypedEventFilter<ApprovalForAllEvent>;

export interface CashBalanceChangeEventObject {
  account: string;
  currencyId: number;
  netCashChange: BigNumber;
}
export type CashBalanceChangeEvent = TypedEvent<
  [string, number, BigNumber],
  CashBalanceChangeEventObject
>;

export type CashBalanceChangeEventFilter =
  TypedEventFilter<CashBalanceChangeEvent>;

export interface DeployNTokenEventObject {
  currencyId: number;
  nTokenAddress: string;
}
export type DeployNTokenEvent = TypedEvent<
  [number, string],
  DeployNTokenEventObject
>;

export type DeployNTokenEventFilter = TypedEventFilter<DeployNTokenEvent>;

export interface ExcessReserveBalanceHarvestedEventObject {
  currencyId: number;
  harvestAmount: BigNumber;
}
export type ExcessReserveBalanceHarvestedEvent = TypedEvent<
  [number, BigNumber],
  ExcessReserveBalanceHarvestedEventObject
>;

export type ExcessReserveBalanceHarvestedEventFilter =
  TypedEventFilter<ExcessReserveBalanceHarvestedEvent>;

export interface IncentivesMigratedEventObject {
  currencyId: number;
  migrationEmissionRate: BigNumber;
  finalIntegralTotalSupply: BigNumber;
  migrationTime: BigNumber;
}
export type IncentivesMigratedEvent = TypedEvent<
  [number, BigNumber, BigNumber, BigNumber],
  IncentivesMigratedEventObject
>;

export type IncentivesMigratedEventFilter =
  TypedEventFilter<IncentivesMigratedEvent>;

export interface LendBorrowTradeEventObject {
  account: string;
  currencyId: number;
  maturity: number;
  netAssetCash: BigNumber;
  netfCash: BigNumber;
}
export type LendBorrowTradeEvent = TypedEvent<
  [string, number, number, BigNumber, BigNumber],
  LendBorrowTradeEventObject
>;

export type LendBorrowTradeEventFilter = TypedEventFilter<LendBorrowTradeEvent>;

export interface LiquidateCollateralCurrencyEventObject {
  liquidated: string;
  liquidator: string;
  localCurrencyId: number;
  collateralCurrencyId: number;
  netLocalFromLiquidator: BigNumber;
  netCollateralTransfer: BigNumber;
  netNTokenTransfer: BigNumber;
}
export type LiquidateCollateralCurrencyEvent = TypedEvent<
  [string, string, number, number, BigNumber, BigNumber, BigNumber],
  LiquidateCollateralCurrencyEventObject
>;

export type LiquidateCollateralCurrencyEventFilter =
  TypedEventFilter<LiquidateCollateralCurrencyEvent>;

export interface LiquidateLocalCurrencyEventObject {
  liquidated: string;
  liquidator: string;
  localCurrencyId: number;
  netLocalFromLiquidator: BigNumber;
}
export type LiquidateLocalCurrencyEvent = TypedEvent<
  [string, string, number, BigNumber],
  LiquidateLocalCurrencyEventObject
>;

export type LiquidateLocalCurrencyEventFilter =
  TypedEventFilter<LiquidateLocalCurrencyEvent>;

export interface LiquidatefCashEventEventObject {
  liquidated: string;
  liquidator: string;
  localCurrencyId: number;
  fCashCurrency: number;
  netLocalFromLiquidator: BigNumber;
  fCashMaturities: BigNumber[];
  fCashNotionalTransfer: BigNumber[];
}
export type LiquidatefCashEventEvent = TypedEvent<
  [string, string, number, number, BigNumber, BigNumber[], BigNumber[]],
  LiquidatefCashEventEventObject
>;

export type LiquidatefCashEventEventFilter =
  TypedEventFilter<LiquidatefCashEventEvent>;

export interface ListCurrencyEventObject {
  newCurrencyId: number;
}
export type ListCurrencyEvent = TypedEvent<[number], ListCurrencyEventObject>;

export type ListCurrencyEventFilter = TypedEventFilter<ListCurrencyEvent>;

export interface MarketsInitializedEventObject {
  currencyId: number;
}
export type MarketsInitializedEvent = TypedEvent<
  [number],
  MarketsInitializedEventObject
>;

export type MarketsInitializedEventFilter =
  TypedEventFilter<MarketsInitializedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface PauseRouterAndGuardianUpdatedEventObject {
  pauseRouter: string;
  pauseGuardian: string;
}
export type PauseRouterAndGuardianUpdatedEvent = TypedEvent<
  [string, string],
  PauseRouterAndGuardianUpdatedEventObject
>;

export type PauseRouterAndGuardianUpdatedEventFilter =
  TypedEventFilter<PauseRouterAndGuardianUpdatedEvent>;

export interface ProtocolInsolvencyEventObject {
  vault: string;
  currencyId: number;
  maturity: BigNumber;
  shortfall: BigNumber;
}
export type ProtocolInsolvencyEvent = TypedEvent<
  [string, number, BigNumber, BigNumber],
  ProtocolInsolvencyEventObject
>;

export type ProtocolInsolvencyEventFilter =
  TypedEventFilter<ProtocolInsolvencyEvent>;

export interface ReserveBalanceUpdatedEventObject {
  currencyId: number;
  newBalance: BigNumber;
}
export type ReserveBalanceUpdatedEvent = TypedEvent<
  [number, BigNumber],
  ReserveBalanceUpdatedEventObject
>;

export type ReserveBalanceUpdatedEventFilter =
  TypedEventFilter<ReserveBalanceUpdatedEvent>;

export interface ReserveBufferUpdatedEventObject {
  currencyId: number;
  bufferAmount: BigNumber;
}
export type ReserveBufferUpdatedEvent = TypedEvent<
  [number, BigNumber],
  ReserveBufferUpdatedEventObject
>;

export type ReserveBufferUpdatedEventFilter =
  TypedEventFilter<ReserveBufferUpdatedEvent>;

export interface ReserveFeeAccruedEventObject {
  currencyId: number;
  fee: BigNumber;
}
export type ReserveFeeAccruedEvent = TypedEvent<
  [number, BigNumber],
  ReserveFeeAccruedEventObject
>;

export type ReserveFeeAccruedEventFilter =
  TypedEventFilter<ReserveFeeAccruedEvent>;

export interface SetSettlementRateEventObject {
  currencyId: BigNumber;
  maturity: BigNumber;
  rate: BigNumber;
}
export type SetSettlementRateEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber],
  SetSettlementRateEventObject
>;

export type SetSettlementRateEventFilter =
  TypedEventFilter<SetSettlementRateEvent>;

export interface SettledCashDebtEventObject {
  settledAccount: string;
  currencyId: number;
  settler: string;
  amountToSettleAsset: BigNumber;
  fCashAmount: BigNumber;
}
export type SettledCashDebtEvent = TypedEvent<
  [string, number, string, BigNumber, BigNumber],
  SettledCashDebtEventObject
>;

export type SettledCashDebtEventFilter = TypedEventFilter<SettledCashDebtEvent>;

export interface SweepCashIntoMarketsEventObject {
  currencyId: number;
  cashIntoMarkets: BigNumber;
}
export type SweepCashIntoMarketsEvent = TypedEvent<
  [number, BigNumber],
  SweepCashIntoMarketsEventObject
>;

export type SweepCashIntoMarketsEventFilter =
  TypedEventFilter<SweepCashIntoMarketsEvent>;

export interface TransferEventObject {
  from: string;
  to: string;
  amount: BigNumber;
}
export type TransferEvent = TypedEvent<
  [string, string, BigNumber],
  TransferEventObject
>;

export type TransferEventFilter = TypedEventFilter<TransferEvent>;

export interface TransferBatchEventObject {
  operator: string;
  from: string;
  to: string;
  ids: BigNumber[];
  values: BigNumber[];
}
export type TransferBatchEvent = TypedEvent<
  [string, string, string, BigNumber[], BigNumber[]],
  TransferBatchEventObject
>;

export type TransferBatchEventFilter = TypedEventFilter<TransferBatchEvent>;

export interface TransferSingleEventObject {
  operator: string;
  from: string;
  to: string;
  id: BigNumber;
  value: BigNumber;
}
export type TransferSingleEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  TransferSingleEventObject
>;

export type TransferSingleEventFilter = TypedEventFilter<TransferSingleEvent>;

export interface TreasuryManagerChangedEventObject {
  previousManager: string;
  newManager: string;
}
export type TreasuryManagerChangedEvent = TypedEvent<
  [string, string],
  TreasuryManagerChangedEventObject
>;

export type TreasuryManagerChangedEventFilter =
  TypedEventFilter<TreasuryManagerChangedEvent>;

export interface URIEventObject {
  value: string;
  id: BigNumber;
}
export type URIEvent = TypedEvent<[string, BigNumber], URIEventObject>;

export type URIEventFilter = TypedEventFilter<URIEvent>;

export interface UpdateAssetRateEventObject {
  currencyId: number;
}
export type UpdateAssetRateEvent = TypedEvent<
  [number],
  UpdateAssetRateEventObject
>;

export type UpdateAssetRateEventFilter = TypedEventFilter<UpdateAssetRateEvent>;

export interface UpdateAuthorizedCallbackContractEventObject {
  operator: string;
  approved: boolean;
}
export type UpdateAuthorizedCallbackContractEvent = TypedEvent<
  [string, boolean],
  UpdateAuthorizedCallbackContractEventObject
>;

export type UpdateAuthorizedCallbackContractEventFilter =
  TypedEventFilter<UpdateAuthorizedCallbackContractEvent>;

export interface UpdateCashGroupEventObject {
  currencyId: number;
}
export type UpdateCashGroupEvent = TypedEvent<
  [number],
  UpdateCashGroupEventObject
>;

export type UpdateCashGroupEventFilter = TypedEventFilter<UpdateCashGroupEvent>;

export interface UpdateDepositParametersEventObject {
  currencyId: number;
}
export type UpdateDepositParametersEvent = TypedEvent<
  [number],
  UpdateDepositParametersEventObject
>;

export type UpdateDepositParametersEventFilter =
  TypedEventFilter<UpdateDepositParametersEvent>;

export interface UpdateETHRateEventObject {
  currencyId: number;
}
export type UpdateETHRateEvent = TypedEvent<[number], UpdateETHRateEventObject>;

export type UpdateETHRateEventFilter = TypedEventFilter<UpdateETHRateEvent>;

export interface UpdateGlobalTransferOperatorEventObject {
  operator: string;
  approved: boolean;
}
export type UpdateGlobalTransferOperatorEvent = TypedEvent<
  [string, boolean],
  UpdateGlobalTransferOperatorEventObject
>;

export type UpdateGlobalTransferOperatorEventFilter =
  TypedEventFilter<UpdateGlobalTransferOperatorEvent>;

export interface UpdateIncentiveEmissionRateEventObject {
  currencyId: number;
  newEmissionRate: number;
}
export type UpdateIncentiveEmissionRateEvent = TypedEvent<
  [number, number],
  UpdateIncentiveEmissionRateEventObject
>;

export type UpdateIncentiveEmissionRateEventFilter =
  TypedEventFilter<UpdateIncentiveEmissionRateEvent>;

export interface UpdateInitializationParametersEventObject {
  currencyId: number;
}
export type UpdateInitializationParametersEvent = TypedEvent<
  [number],
  UpdateInitializationParametersEventObject
>;

export type UpdateInitializationParametersEventFilter =
  TypedEventFilter<UpdateInitializationParametersEvent>;

export interface UpdateLendingPoolEventObject {
  pool: string;
}
export type UpdateLendingPoolEvent = TypedEvent<
  [string],
  UpdateLendingPoolEventObject
>;

export type UpdateLendingPoolEventFilter =
  TypedEventFilter<UpdateLendingPoolEvent>;

export interface UpdateMaxCollateralBalanceEventObject {
  currencyId: number;
  maxCollateralBalance: BigNumber;
}
export type UpdateMaxCollateralBalanceEvent = TypedEvent<
  [number, BigNumber],
  UpdateMaxCollateralBalanceEventObject
>;

export type UpdateMaxCollateralBalanceEventFilter =
  TypedEventFilter<UpdateMaxCollateralBalanceEvent>;

export interface UpdateSecondaryIncentiveRewarderEventObject {
  currencyId: number;
  rewarder: string;
}
export type UpdateSecondaryIncentiveRewarderEvent = TypedEvent<
  [number, string],
  UpdateSecondaryIncentiveRewarderEventObject
>;

export type UpdateSecondaryIncentiveRewarderEventFilter =
  TypedEventFilter<UpdateSecondaryIncentiveRewarderEvent>;

export interface UpdateTokenCollateralParametersEventObject {
  currencyId: number;
}
export type UpdateTokenCollateralParametersEvent = TypedEvent<
  [number],
  UpdateTokenCollateralParametersEventObject
>;

export type UpdateTokenCollateralParametersEventFilter =
  TypedEventFilter<UpdateTokenCollateralParametersEvent>;

export interface VaultBorrowCapacityChangeEventObject {
  vault: string;
  currencyId: number;
  totalUsedBorrowCapacity: BigNumber;
}
export type VaultBorrowCapacityChangeEvent = TypedEvent<
  [string, number, BigNumber],
  VaultBorrowCapacityChangeEventObject
>;

export type VaultBorrowCapacityChangeEventFilter =
  TypedEventFilter<VaultBorrowCapacityChangeEvent>;

export interface VaultDeleverageAccountEventObject {
  vault: string;
  account: string;
  vaultSharesToLiquidator: BigNumber;
  fCashRepaid: BigNumber;
}
export type VaultDeleverageAccountEvent = TypedEvent<
  [string, string, BigNumber, BigNumber],
  VaultDeleverageAccountEventObject
>;

export type VaultDeleverageAccountEventFilter =
  TypedEventFilter<VaultDeleverageAccountEvent>;

export interface VaultEnterMaturityEventObject {
  vault: string;
  maturity: BigNumber;
  account: string;
  underlyingTokensTransferred: BigNumber;
  strategyTokenDeposited: BigNumber;
  vaultSharesMinted: BigNumber;
}
export type VaultEnterMaturityEvent = TypedEvent<
  [string, BigNumber, string, BigNumber, BigNumber, BigNumber],
  VaultEnterMaturityEventObject
>;

export type VaultEnterMaturityEventFilter =
  TypedEventFilter<VaultEnterMaturityEvent>;

export interface VaultEnterPositionEventObject {
  vault: string;
  account: string;
  maturity: BigNumber;
  fCashBorrowed: BigNumber;
}
export type VaultEnterPositionEvent = TypedEvent<
  [string, string, BigNumber, BigNumber],
  VaultEnterPositionEventObject
>;

export type VaultEnterPositionEventFilter =
  TypedEventFilter<VaultEnterPositionEvent>;

export interface VaultExitPostMaturityEventObject {
  vault: string;
  account: string;
  maturity: BigNumber;
  underlyingToReceiver: BigNumber;
}
export type VaultExitPostMaturityEvent = TypedEvent<
  [string, string, BigNumber, BigNumber],
  VaultExitPostMaturityEventObject
>;

export type VaultExitPostMaturityEventFilter =
  TypedEventFilter<VaultExitPostMaturityEvent>;

export interface VaultExitPreMaturityEventObject {
  vault: string;
  account: string;
  maturity: BigNumber;
  fCashToLend: BigNumber;
  vaultSharesToRedeem: BigNumber;
  underlyingToReceiver: BigNumber;
}
export type VaultExitPreMaturityEvent = TypedEvent<
  [string, string, BigNumber, BigNumber, BigNumber, BigNumber],
  VaultExitPreMaturityEventObject
>;

export type VaultExitPreMaturityEventFilter =
  TypedEventFilter<VaultExitPreMaturityEvent>;

export interface VaultFeeAccruedEventObject {
  vault: string;
  currencyId: number;
  maturity: BigNumber;
  reserveFee: BigNumber;
  nTokenFee: BigNumber;
}
export type VaultFeeAccruedEvent = TypedEvent<
  [string, number, BigNumber, BigNumber, BigNumber],
  VaultFeeAccruedEventObject
>;

export type VaultFeeAccruedEventFilter = TypedEventFilter<VaultFeeAccruedEvent>;

export interface VaultLiquidatorProfitEventObject {
  vault: string;
  account: string;
  liquidator: string;
  vaultSharesToLiquidator: BigNumber;
  transferSharesToLiquidator: boolean;
}
export type VaultLiquidatorProfitEvent = TypedEvent<
  [string, string, string, BigNumber, boolean],
  VaultLiquidatorProfitEventObject
>;

export type VaultLiquidatorProfitEventFilter =
  TypedEventFilter<VaultLiquidatorProfitEvent>;

export interface VaultMintStrategyTokenEventObject {
  vault: string;
  maturity: BigNumber;
  assetCashDeposited: BigNumber;
  strategyTokensMinted: BigNumber;
}
export type VaultMintStrategyTokenEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber],
  VaultMintStrategyTokenEventObject
>;

export type VaultMintStrategyTokenEventFilter =
  TypedEventFilter<VaultMintStrategyTokenEvent>;

export interface VaultPauseStatusEventObject {
  vault: string;
  enabled: boolean;
}
export type VaultPauseStatusEvent = TypedEvent<
  [string, boolean],
  VaultPauseStatusEventObject
>;

export type VaultPauseStatusEventFilter =
  TypedEventFilter<VaultPauseStatusEvent>;

export interface VaultRedeemStrategyTokenEventObject {
  vault: string;
  maturity: BigNumber;
  assetCashReceived: BigNumber;
  strategyTokensRedeemed: BigNumber;
}
export type VaultRedeemStrategyTokenEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber],
  VaultRedeemStrategyTokenEventObject
>;

export type VaultRedeemStrategyTokenEventFilter =
  TypedEventFilter<VaultRedeemStrategyTokenEvent>;

export interface VaultRepaySecondaryBorrowEventObject {
  vault: string;
  account: string;
  currencyId: number;
  maturity: BigNumber;
  debtSharesRepaid: BigNumber;
  fCashLent: BigNumber;
}
export type VaultRepaySecondaryBorrowEvent = TypedEvent<
  [string, string, number, BigNumber, BigNumber, BigNumber],
  VaultRepaySecondaryBorrowEventObject
>;

export type VaultRepaySecondaryBorrowEventFilter =
  TypedEventFilter<VaultRepaySecondaryBorrowEvent>;

export interface VaultRollPositionEventObject {
  vault: string;
  account: string;
  newMaturity: BigNumber;
  fCashBorrowed: BigNumber;
}
export type VaultRollPositionEvent = TypedEvent<
  [string, string, BigNumber, BigNumber],
  VaultRollPositionEventObject
>;

export type VaultRollPositionEventFilter =
  TypedEventFilter<VaultRollPositionEvent>;

export interface VaultSecondaryBorrowEventObject {
  vault: string;
  account: string;
  currencyId: number;
  maturity: BigNumber;
  debtSharesMinted: BigNumber;
  fCashBorrowed: BigNumber;
}
export type VaultSecondaryBorrowEvent = TypedEvent<
  [string, string, number, BigNumber, BigNumber, BigNumber],
  VaultSecondaryBorrowEventObject
>;

export type VaultSecondaryBorrowEventFilter =
  TypedEventFilter<VaultSecondaryBorrowEvent>;

export interface VaultSecondaryBorrowSnapshotEventObject {
  vault: string;
  currencyId: number;
  maturity: BigNumber;
  totalfCashBorrowedInPrimarySnapshot: BigNumber;
  exchangeRate: BigNumber;
}
export type VaultSecondaryBorrowSnapshotEvent = TypedEvent<
  [string, number, BigNumber, BigNumber, BigNumber],
  VaultSecondaryBorrowSnapshotEventObject
>;

export type VaultSecondaryBorrowSnapshotEventFilter =
  TypedEventFilter<VaultSecondaryBorrowSnapshotEvent>;

export interface VaultSettledEventObject {
  vault: string;
  maturity: BigNumber;
  totalfCash: BigNumber;
  totalAssetCash: BigNumber;
  totalStrategyTokens: BigNumber;
  totalVaultShares: BigNumber;
  strategyTokenValue: BigNumber;
}
export type VaultSettledEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber],
  VaultSettledEventObject
>;

export type VaultSettledEventFilter = TypedEventFilter<VaultSettledEvent>;

export interface VaultSettledAssetsRemainingEventObject {
  vault: string;
  maturity: BigNumber;
  remainingAssetCash: BigNumber;
  remainingStrategyTokens: BigNumber;
}
export type VaultSettledAssetsRemainingEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber],
  VaultSettledAssetsRemainingEventObject
>;

export type VaultSettledAssetsRemainingEventFilter =
  TypedEventFilter<VaultSettledAssetsRemainingEvent>;

export interface VaultShortfallEventObject {
  vault: string;
  currencyId: number;
  maturity: BigNumber;
  shortfall: BigNumber;
}
export type VaultShortfallEvent = TypedEvent<
  [string, number, BigNumber, BigNumber],
  VaultShortfallEventObject
>;

export type VaultShortfallEventFilter = TypedEventFilter<VaultShortfallEvent>;

export interface VaultStateUpdateEventObject {
  vault: string;
  maturity: BigNumber;
  totalfCash: BigNumber;
  totalAssetCash: BigNumber;
  totalStrategyTokens: BigNumber;
  totalVaultShares: BigNumber;
}
export type VaultStateUpdateEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber],
  VaultStateUpdateEventObject
>;

export type VaultStateUpdateEventFilter =
  TypedEventFilter<VaultStateUpdateEvent>;

export interface VaultUpdateSecondaryBorrowCapacityEventObject {
  vault: string;
  currencyId: number;
  maxSecondaryBorrowCapacity: BigNumber;
}
export type VaultUpdateSecondaryBorrowCapacityEvent = TypedEvent<
  [string, number, BigNumber],
  VaultUpdateSecondaryBorrowCapacityEventObject
>;

export type VaultUpdateSecondaryBorrowCapacityEventFilter =
  TypedEventFilter<VaultUpdateSecondaryBorrowCapacityEvent>;

export interface VaultUpdatedEventObject {
  vault: string;
  enabled: boolean;
  maxPrimaryBorrowCapacity: BigNumber;
}
export type VaultUpdatedEvent = TypedEvent<
  [string, boolean, BigNumber],
  VaultUpdatedEventObject
>;

export type VaultUpdatedEventFilter = TypedEventFilter<VaultUpdatedEvent>;

export interface nTokenResidualPurchaseEventObject {
  currencyId: number;
  maturity: number;
  purchaser: string;
  fCashAmountToPurchase: BigNumber;
  netAssetCashNToken: BigNumber;
}
export type nTokenResidualPurchaseEvent = TypedEvent<
  [number, number, string, BigNumber, BigNumber],
  nTokenResidualPurchaseEventObject
>;

export type nTokenResidualPurchaseEventFilter =
  TypedEventFilter<nTokenResidualPurchaseEvent>;

export interface nTokenSupplyChangeEventObject {
  account: string;
  currencyId: number;
  tokenSupplyChange: BigNumber;
}
export type nTokenSupplyChangeEvent = TypedEvent<
  [string, number, BigNumber],
  nTokenSupplyChangeEventObject
>;

export type nTokenSupplyChangeEventFilter =
  TypedEventFilter<nTokenSupplyChangeEvent>;

export interface Notional extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: NotionalInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    balanceOf(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    balanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    batchBalanceAction(
      account: PromiseOrValue<string>,
      actions: BalanceActionStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    batchBalanceAndTradeAction(
      account: PromiseOrValue<string>,
      actions: BalanceActionWithTradesStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    batchBalanceAndTradeActionWithCallback(
      account: PromiseOrValue<string>,
      actions: BalanceActionWithTradesStruct[],
      callbackData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    batchLend(
      account: PromiseOrValue<string>,
      actions: BatchLendStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    borrowSecondaryCurrencyToVault(
      account: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      fCashToBorrow: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      maxBorrowRate: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      minRollLendRate: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    calculateCollateralCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      collateralCurrency: PromiseOrValue<BigNumberish>,
      maxCollateralLiquidation: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    calculateLocalCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    calculateNTokensToMint(
      currencyId: PromiseOrValue<BigNumberish>,
      amountToDepositExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    calculatefCashCrossCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    calculatefCashLocalLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    claimCOMPAndTransfer(
      ctokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    claimOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    convertCashBalanceToExternal(
      currencyId: PromiseOrValue<BigNumberish>,
      cashBalanceInternal: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    decodeToAssets(
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<[PortfolioAssetStructOutput[]]>;

    deleverageAccount(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      liquidator: PromiseOrValue<string>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      transferSharesToLiquidator: PromiseOrValue<boolean>,
      redeemData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    depositAssetToken(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      amountExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    depositUnderlyingToken(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      amountExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    depositVaultCashToStrategyTokens(
      maturity: PromiseOrValue<BigNumberish>,
      assetCashToDepositExternal: PromiseOrValue<BigNumberish>,
      vaultData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    enableBitmapCurrency(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    enableCashGroup(
      currencyId: PromiseOrValue<BigNumberish>,
      assetRateOracle: PromiseOrValue<string>,
      cashGroup: CashGroupSettingsStruct,
      underlyingName: PromiseOrValue<string>,
      underlyingSymbol: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    encodeToId(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { id: BigNumber }>;

    enterVault(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      fCash: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      vaultData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    exitVault(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      vaultSharesToRedeem: PromiseOrValue<BigNumberish>,
      fCashToLend: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      exitVaultData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getAccount(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        AccountContextStructOutput,
        AccountBalanceStructOutput[],
        PortfolioAssetStructOutput[]
      ] & {
        accountContext: AccountContextStructOutput;
        accountBalances: AccountBalanceStructOutput[];
        portfolio: PortfolioAssetStructOutput[];
      }
    >;

    getAccountBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        cashBalance: BigNumber;
        nTokenBalance: BigNumber;
        lastClaimTime: BigNumber;
      }
    >;

    getAccountContext(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[AccountContextStructOutput]>;

    getAccountPortfolio(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[PortfolioAssetStructOutput[]]>;

    getActiveMarkets(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[MarketParametersStructOutput[]]>;

    getActiveMarketsAtBlockTime(
      currencyId: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[MarketParametersStructOutput[]]>;

    getAssetsBitmap(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getAuthorizedCallbackContractStatus(
      callback: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isAuthorized: boolean }>;

    getBorrowCapacity(
      vault: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        totalUsedBorrowCapacity: BigNumber;
        maxBorrowCapacity: BigNumber;
      }
    >;

    getCashAmountGivenfCashAmount(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashAmount: PromiseOrValue<BigNumberish>,
      marketIndex: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    getCashGroup(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[CashGroupSettingsStructOutput]>;

    getCashGroupAndAssetRate(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [CashGroupSettingsStructOutput, AssetRateParametersStructOutput] & {
        cashGroup: CashGroupSettingsStructOutput;
        assetRate: AssetRateParametersStructOutput;
      }
    >;

    getCashRequiredToSettle(
      vault: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        assetCashRequiredToSettle: BigNumber;
        underlyingCashRequiredToSettle: BigNumber;
      }
    >;

    getCurrency(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [TokenStructOutput, TokenStructOutput] & {
        assetToken: TokenStructOutput;
        underlyingToken: TokenStructOutput;
      }
    >;

    getCurrencyAndRates(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        TokenStructOutput,
        TokenStructOutput,
        ETHRateStructOutput,
        AssetRateParametersStructOutput
      ] & {
        assetToken: TokenStructOutput;
        underlyingToken: TokenStructOutput;
        ethRate: ETHRateStructOutput;
        assetRate: AssetRateParametersStructOutput;
      }
    >;

    getCurrencyId(
      tokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[number] & { currencyId: number }>;

    getDepositFromfCashLend(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashAmount: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, number, string] & {
        depositAmountUnderlying: BigNumber;
        depositAmountAsset: BigNumber;
        marketIndex: number;
        encodedTrade: string;
      }
    >;

    getDepositParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber[]] & {
        depositShares: BigNumber[];
        leverageThresholds: BigNumber[];
      }
    >;

    getFreeCollateral(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber[]]>;

    getGlobalTransferOperatorStatus(
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isAuthorized: boolean }>;

    getImplementation(overrides?: CallOverrides): Promise<[string]>;

    getInitializationParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber[]] & {
        annualizedAnchorRates: BigNumber[];
        proportions: BigNumber[];
      }
    >;

    getLendingPool(overrides?: CallOverrides): Promise<[string]>;

    getMarket(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      settlementDate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[MarketParametersStructOutput]>;

    getMarketIndex(
      maturity: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[number] & { marketIndex: number }>;

    getMaxCurrencyId(overrides?: CallOverrides): Promise<[number]>;

    getNTokenAccount(
      tokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        number,
        BigNumber,
        BigNumber,
        BigNumber,
        string,
        BigNumber,
        BigNumber,
        BigNumber
      ] & {
        currencyId: number;
        totalSupply: BigNumber;
        incentiveAnnualEmissionRate: BigNumber;
        lastInitializedTime: BigNumber;
        nTokenParameters: string;
        cashBalance: BigNumber;
        accumulatedNOTEPerNToken: BigNumber;
        lastAccumulatedTime: BigNumber;
      }
    >;

    getNTokenPortfolio(
      tokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [PortfolioAssetStructOutput[], PortfolioAssetStructOutput[]] & {
        liquidityTokens: PortfolioAssetStructOutput[];
        netfCashAssets: PortfolioAssetStructOutput[];
      }
    >;

    getNoteToken(overrides?: CallOverrides): Promise<[string]>;

    getOwnershipStatus(
      overrides?: CallOverrides
    ): Promise<[string, string] & { owner: string; pendingOwner: string }>;

    getPresentfCashValue(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      notional: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      riskAdjusted: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { presentValue: BigNumber }>;

    getPrincipalFromfCashBorrow(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashBorrow: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, number, string] & {
        borrowAmountUnderlying: BigNumber;
        borrowAmountAsset: BigNumber;
        marketIndex: number;
        encodedTrade: string;
      }
    >;

    getRateStorage(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [ETHRateStorageStructOutput, AssetRateStorageStructOutput] & {
        ethRate: ETHRateStorageStructOutput;
        assetRate: AssetRateStorageStructOutput;
      }
    >;

    getReserveBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { reserveBalance: BigNumber }>;

    getReserveBuffer(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getSecondaryBorrow(
      vault: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        totalfCashBorrowed: BigNumber;
        totalAccountDebtShares: BigNumber;
        totalfCashBorrowedInPrimarySnapshot: BigNumber;
      }
    >;

    getSecondaryIncentiveRewarder(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string] & { incentiveRewarder: string }>;

    getSettlementRate(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[AssetRateParametersStructOutput]>;

    getTreasuryManager(overrides?: CallOverrides): Promise<[string]>;

    getVaultAccount(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[VaultAccountStructOutput]>;

    getVaultAccountCollateralRatio(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        collateralRatio: BigNumber;
        minCollateralRatio: BigNumber;
        maxLiquidatorDepositAssetCash: BigNumber;
      }
    >;

    getVaultAccountDebtShares(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, [BigNumber, BigNumber], BigNumber] & {
        debtSharesMaturity: BigNumber;
        accountDebtShares: [BigNumber, BigNumber];
        accountStrategyTokens: BigNumber;
      }
    >;

    getVaultConfig(
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [VaultConfigStructOutput] & { vaultConfig: VaultConfigStructOutput }
    >;

    getVaultState(
      vault: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [VaultStateStructOutput] & { vaultState: VaultStateStructOutput }
    >;

    getfCashAmountGivenCashAmount(
      currencyId: PromiseOrValue<BigNumberish>,
      netCashToAccount: PromiseOrValue<BigNumberish>,
      marketIndex: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getfCashBorrowFromPrincipal(
      currencyId: PromiseOrValue<BigNumberish>,
      borrowedAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, number, string] & {
        fCashDebt: BigNumber;
        marketIndex: number;
        encodedTrade: string;
      }
    >;

    getfCashLendFromDeposit(
      currencyId: PromiseOrValue<BigNumberish>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, number, string] & {
        fCashAmount: BigNumber;
        marketIndex: number;
        encodedTrade: string;
      }
    >;

    getfCashNotional(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    initializeMarkets(
      currencyId: PromiseOrValue<BigNumberish>,
      isFirstInit: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    initiateSecondaryBorrowSettlement(
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isApprovedForAll(
      account: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    liquidateCollateralCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      collateralCurrency: PromiseOrValue<BigNumberish>,
      maxCollateralLiquidation: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      withdrawCollateral: PromiseOrValue<boolean>,
      redeemToUnderlying: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    liquidateLocalCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    liquidatefCashCrossCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    liquidatefCashLocal(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    listCurrency(
      assetToken: TokenStorageStruct,
      underlyingToken: TokenStorageStruct,
      rateOracle: PromiseOrValue<string>,
      mustInvert: PromiseOrValue<boolean>,
      buffer: PromiseOrValue<BigNumberish>,
      haircut: PromiseOrValue<BigNumberish>,
      liquidationDiscount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    nTokenAddress(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    nTokenBalanceOf(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    nTokenClaimIncentives(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    nTokenGetClaimableIncentives(
      account: PromiseOrValue<string>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    nTokenPresentValueAssetDenominated(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    nTokenPresentValueUnderlyingDenominated(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    nTokenRedeem(
      redeemer: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      tokensToRedeem_: PromiseOrValue<BigNumberish>,
      sellTokenAssets: PromiseOrValue<boolean>,
      acceptResidualAssets: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    nTokenTotalSupply(
      nTokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    nTokenTransfer(
      currencyId: PromiseOrValue<BigNumberish>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    nTokenTransferAllowance(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    nTokenTransferApprove(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    nTokenTransferApproveAll(
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    nTokenTransferFrom(
      currencyId: PromiseOrValue<BigNumberish>,
      spender: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pauseGuardian(overrides?: CallOverrides): Promise<[string]>;

    pauseRouter(overrides?: CallOverrides): Promise<[string]>;

    redeemStrategyTokensToCash(
      maturity: PromiseOrValue<BigNumberish>,
      strategyTokensToRedeem: PromiseOrValue<BigNumberish>,
      vaultData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    reduceMaxBorrowCapacity(
      vaultAddress: PromiseOrValue<string>,
      maxVaultBorrowCapacity: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      strategyTokensToRedeem: PromiseOrValue<BigNumberish>,
      vaultData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    repaySecondaryCurrencyFromVault(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      fCashToRepay: PromiseOrValue<BigNumberish>,
      slippageLimit: PromiseOrValue<BigNumberish>,
      callbackData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    rollVaultPosition(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      fCashToBorrow: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      enterVaultData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    safeBatchTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    safeTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setLendingPool(
      pool: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMaxBorrowCapacity(
      vaultAddress: PromiseOrValue<string>,
      maxVaultBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setPauseRouterAndGuardian(
      pauseRouter_: PromiseOrValue<string>,
      pauseGuardian_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setReserveBuffer(
      currencyId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setReserveCashBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      reserveBalance: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setSecondaryIncentiveRewarder(
      currencyId: PromiseOrValue<BigNumberish>,
      rewarder: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setTreasuryManager(
      manager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setVaultPauseStatus(
      vaultAddress: PromiseOrValue<string>,
      enable: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    settleAccount(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    settleVault(
      vault: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    signedBalanceOf(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    signedBalanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    sweepCashIntoMarkets(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      direct: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferReserveToTreasury(
      currencies: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateAssetRate(
      currencyId: PromiseOrValue<BigNumberish>,
      rateOracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateAuthorizedCallbackContract(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateCashGroup(
      currencyId: PromiseOrValue<BigNumberish>,
      cashGroup: CashGroupSettingsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateDepositParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      depositShares: PromiseOrValue<BigNumberish>[],
      leverageThresholds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateETHRate(
      currencyId: PromiseOrValue<BigNumberish>,
      rateOracle: PromiseOrValue<string>,
      mustInvert: PromiseOrValue<boolean>,
      buffer: PromiseOrValue<BigNumberish>,
      haircut: PromiseOrValue<BigNumberish>,
      liquidationDiscount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateGlobalTransferOperator(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateIncentiveEmissionRate(
      currencyId: PromiseOrValue<BigNumberish>,
      newEmissionRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateInitializationParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      annualizedAnchorRates: PromiseOrValue<BigNumberish>[],
      proportions: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateMaxCollateralBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      maxCollateralBalanceInternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateSecondaryBorrowCapacity(
      vaultAddress: PromiseOrValue<string>,
      secondaryCurrencyId: PromiseOrValue<BigNumberish>,
      maxBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateTokenCollateralParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      residualPurchaseIncentive10BPS: PromiseOrValue<BigNumberish>,
      pvHaircutPercentage: PromiseOrValue<BigNumberish>,
      residualPurchaseTimeBufferHours: PromiseOrValue<BigNumberish>,
      cashWithholdingBuffer10BPS: PromiseOrValue<BigNumberish>,
      liquidationHaircutPercentage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateVault(
      vaultAddress: PromiseOrValue<string>,
      vaultConfig: VaultConfigStorageStruct,
      maxPrimaryBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdraw(
      currencyId: PromiseOrValue<BigNumberish>,
      amountInternalPrecision: PromiseOrValue<BigNumberish>,
      redeemToUnderlying: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  balanceOf(
    account: PromiseOrValue<string>,
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  balanceOfBatch(
    accounts: PromiseOrValue<string>[],
    ids: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  batchBalanceAction(
    account: PromiseOrValue<string>,
    actions: BalanceActionStruct[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  batchBalanceAndTradeAction(
    account: PromiseOrValue<string>,
    actions: BalanceActionWithTradesStruct[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  batchBalanceAndTradeActionWithCallback(
    account: PromiseOrValue<string>,
    actions: BalanceActionWithTradesStruct[],
    callbackData: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  batchLend(
    account: PromiseOrValue<string>,
    actions: BatchLendStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  borrowSecondaryCurrencyToVault(
    account: PromiseOrValue<string>,
    maturity: PromiseOrValue<BigNumberish>,
    fCashToBorrow: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    maxBorrowRate: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    minRollLendRate: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  calculateCollateralCurrencyLiquidation(
    liquidateAccount: PromiseOrValue<string>,
    localCurrency: PromiseOrValue<BigNumberish>,
    collateralCurrency: PromiseOrValue<BigNumberish>,
    maxCollateralLiquidation: PromiseOrValue<BigNumberish>,
    maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  calculateLocalCurrencyLiquidation(
    liquidateAccount: PromiseOrValue<string>,
    localCurrency: PromiseOrValue<BigNumberish>,
    maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  calculateNTokensToMint(
    currencyId: PromiseOrValue<BigNumberish>,
    amountToDepositExternalPrecision: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  calculatefCashCrossCurrencyLiquidation(
    liquidateAccount: PromiseOrValue<string>,
    localCurrency: PromiseOrValue<BigNumberish>,
    fCashCurrency: PromiseOrValue<BigNumberish>,
    fCashMaturities: PromiseOrValue<BigNumberish>[],
    maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  calculatefCashLocalLiquidation(
    liquidateAccount: PromiseOrValue<string>,
    localCurrency: PromiseOrValue<BigNumberish>,
    fCashMaturities: PromiseOrValue<BigNumberish>[],
    maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  claimCOMPAndTransfer(
    ctokens: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  claimOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  convertCashBalanceToExternal(
    currencyId: PromiseOrValue<BigNumberish>,
    cashBalanceInternal: PromiseOrValue<BigNumberish>,
    useUnderlying: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  decodeToAssets(
    ids: PromiseOrValue<BigNumberish>[],
    amounts: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides
  ): Promise<PortfolioAssetStructOutput[]>;

  deleverageAccount(
    account: PromiseOrValue<string>,
    vault: PromiseOrValue<string>,
    liquidator: PromiseOrValue<string>,
    depositAmountExternal: PromiseOrValue<BigNumberish>,
    transferSharesToLiquidator: PromiseOrValue<boolean>,
    redeemData: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  depositAssetToken(
    account: PromiseOrValue<string>,
    currencyId: PromiseOrValue<BigNumberish>,
    amountExternalPrecision: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  depositUnderlyingToken(
    account: PromiseOrValue<string>,
    currencyId: PromiseOrValue<BigNumberish>,
    amountExternalPrecision: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  depositVaultCashToStrategyTokens(
    maturity: PromiseOrValue<BigNumberish>,
    assetCashToDepositExternal: PromiseOrValue<BigNumberish>,
    vaultData: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  enableBitmapCurrency(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  enableCashGroup(
    currencyId: PromiseOrValue<BigNumberish>,
    assetRateOracle: PromiseOrValue<string>,
    cashGroup: CashGroupSettingsStruct,
    underlyingName: PromiseOrValue<string>,
    underlyingSymbol: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  encodeToId(
    currencyId: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    assetType: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  enterVault(
    account: PromiseOrValue<string>,
    vault: PromiseOrValue<string>,
    depositAmountExternal: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    fCash: PromiseOrValue<BigNumberish>,
    maxBorrowRate: PromiseOrValue<BigNumberish>,
    vaultData: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  exitVault(
    account: PromiseOrValue<string>,
    vault: PromiseOrValue<string>,
    receiver: PromiseOrValue<string>,
    vaultSharesToRedeem: PromiseOrValue<BigNumberish>,
    fCashToLend: PromiseOrValue<BigNumberish>,
    minLendRate: PromiseOrValue<BigNumberish>,
    exitVaultData: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getAccount(
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [
      AccountContextStructOutput,
      AccountBalanceStructOutput[],
      PortfolioAssetStructOutput[]
    ] & {
      accountContext: AccountContextStructOutput;
      accountBalances: AccountBalanceStructOutput[];
      portfolio: PortfolioAssetStructOutput[];
    }
  >;

  getAccountBalance(
    currencyId: PromiseOrValue<BigNumberish>,
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      cashBalance: BigNumber;
      nTokenBalance: BigNumber;
      lastClaimTime: BigNumber;
    }
  >;

  getAccountContext(
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<AccountContextStructOutput>;

  getAccountPortfolio(
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<PortfolioAssetStructOutput[]>;

  getActiveMarkets(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<MarketParametersStructOutput[]>;

  getActiveMarketsAtBlockTime(
    currencyId: PromiseOrValue<BigNumberish>,
    blockTime: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<MarketParametersStructOutput[]>;

  getAssetsBitmap(
    account: PromiseOrValue<string>,
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  getAuthorizedCallbackContractStatus(
    callback: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getBorrowCapacity(
    vault: PromiseOrValue<string>,
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber] & {
      totalUsedBorrowCapacity: BigNumber;
      maxBorrowCapacity: BigNumber;
    }
  >;

  getCashAmountGivenfCashAmount(
    currencyId: PromiseOrValue<BigNumberish>,
    fCashAmount: PromiseOrValue<BigNumberish>,
    marketIndex: PromiseOrValue<BigNumberish>,
    blockTime: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, BigNumber]>;

  getCashGroup(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<CashGroupSettingsStructOutput>;

  getCashGroupAndAssetRate(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [CashGroupSettingsStructOutput, AssetRateParametersStructOutput] & {
      cashGroup: CashGroupSettingsStructOutput;
      assetRate: AssetRateParametersStructOutput;
    }
  >;

  getCashRequiredToSettle(
    vault: PromiseOrValue<string>,
    maturity: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber] & {
      assetCashRequiredToSettle: BigNumber;
      underlyingCashRequiredToSettle: BigNumber;
    }
  >;

  getCurrency(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [TokenStructOutput, TokenStructOutput] & {
      assetToken: TokenStructOutput;
      underlyingToken: TokenStructOutput;
    }
  >;

  getCurrencyAndRates(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [
      TokenStructOutput,
      TokenStructOutput,
      ETHRateStructOutput,
      AssetRateParametersStructOutput
    ] & {
      assetToken: TokenStructOutput;
      underlyingToken: TokenStructOutput;
      ethRate: ETHRateStructOutput;
      assetRate: AssetRateParametersStructOutput;
    }
  >;

  getCurrencyId(
    tokenAddress: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<number>;

  getDepositFromfCashLend(
    currencyId: PromiseOrValue<BigNumberish>,
    fCashAmount: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    minLendRate: PromiseOrValue<BigNumberish>,
    blockTime: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, number, string] & {
      depositAmountUnderlying: BigNumber;
      depositAmountAsset: BigNumber;
      marketIndex: number;
      encodedTrade: string;
    }
  >;

  getDepositParameters(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber[], BigNumber[]] & {
      depositShares: BigNumber[];
      leverageThresholds: BigNumber[];
    }
  >;

  getFreeCollateral(
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, BigNumber[]]>;

  getGlobalTransferOperatorStatus(
    operator: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getImplementation(overrides?: CallOverrides): Promise<string>;

  getInitializationParameters(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber[], BigNumber[]] & {
      annualizedAnchorRates: BigNumber[];
      proportions: BigNumber[];
    }
  >;

  getLendingPool(overrides?: CallOverrides): Promise<string>;

  getMarket(
    currencyId: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    settlementDate: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<MarketParametersStructOutput>;

  getMarketIndex(
    maturity: PromiseOrValue<BigNumberish>,
    blockTime: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<number>;

  getMaxCurrencyId(overrides?: CallOverrides): Promise<number>;

  getNTokenAccount(
    tokenAddress: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [
      number,
      BigNumber,
      BigNumber,
      BigNumber,
      string,
      BigNumber,
      BigNumber,
      BigNumber
    ] & {
      currencyId: number;
      totalSupply: BigNumber;
      incentiveAnnualEmissionRate: BigNumber;
      lastInitializedTime: BigNumber;
      nTokenParameters: string;
      cashBalance: BigNumber;
      accumulatedNOTEPerNToken: BigNumber;
      lastAccumulatedTime: BigNumber;
    }
  >;

  getNTokenPortfolio(
    tokenAddress: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [PortfolioAssetStructOutput[], PortfolioAssetStructOutput[]] & {
      liquidityTokens: PortfolioAssetStructOutput[];
      netfCashAssets: PortfolioAssetStructOutput[];
    }
  >;

  getNoteToken(overrides?: CallOverrides): Promise<string>;

  getOwnershipStatus(
    overrides?: CallOverrides
  ): Promise<[string, string] & { owner: string; pendingOwner: string }>;

  getPresentfCashValue(
    currencyId: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    notional: PromiseOrValue<BigNumberish>,
    blockTime: PromiseOrValue<BigNumberish>,
    riskAdjusted: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getPrincipalFromfCashBorrow(
    currencyId: PromiseOrValue<BigNumberish>,
    fCashBorrow: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    maxBorrowRate: PromiseOrValue<BigNumberish>,
    blockTime: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, number, string] & {
      borrowAmountUnderlying: BigNumber;
      borrowAmountAsset: BigNumber;
      marketIndex: number;
      encodedTrade: string;
    }
  >;

  getRateStorage(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [ETHRateStorageStructOutput, AssetRateStorageStructOutput] & {
      ethRate: ETHRateStorageStructOutput;
      assetRate: AssetRateStorageStructOutput;
    }
  >;

  getReserveBalance(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getReserveBuffer(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getSecondaryBorrow(
    vault: PromiseOrValue<string>,
    currencyId: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      totalfCashBorrowed: BigNumber;
      totalAccountDebtShares: BigNumber;
      totalfCashBorrowedInPrimarySnapshot: BigNumber;
    }
  >;

  getSecondaryIncentiveRewarder(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  getSettlementRate(
    currencyId: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<AssetRateParametersStructOutput>;

  getTreasuryManager(overrides?: CallOverrides): Promise<string>;

  getVaultAccount(
    account: PromiseOrValue<string>,
    vault: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<VaultAccountStructOutput>;

  getVaultAccountCollateralRatio(
    account: PromiseOrValue<string>,
    vault: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      collateralRatio: BigNumber;
      minCollateralRatio: BigNumber;
      maxLiquidatorDepositAssetCash: BigNumber;
    }
  >;

  getVaultAccountDebtShares(
    account: PromiseOrValue<string>,
    vault: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, [BigNumber, BigNumber], BigNumber] & {
      debtSharesMaturity: BigNumber;
      accountDebtShares: [BigNumber, BigNumber];
      accountStrategyTokens: BigNumber;
    }
  >;

  getVaultConfig(
    vault: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<VaultConfigStructOutput>;

  getVaultState(
    vault: PromiseOrValue<string>,
    maturity: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<VaultStateStructOutput>;

  getfCashAmountGivenCashAmount(
    currencyId: PromiseOrValue<BigNumberish>,
    netCashToAccount: PromiseOrValue<BigNumberish>,
    marketIndex: PromiseOrValue<BigNumberish>,
    blockTime: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getfCashBorrowFromPrincipal(
    currencyId: PromiseOrValue<BigNumberish>,
    borrowedAmountExternal: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    maxBorrowRate: PromiseOrValue<BigNumberish>,
    blockTime: PromiseOrValue<BigNumberish>,
    useUnderlying: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, number, string] & {
      fCashDebt: BigNumber;
      marketIndex: number;
      encodedTrade: string;
    }
  >;

  getfCashLendFromDeposit(
    currencyId: PromiseOrValue<BigNumberish>,
    depositAmountExternal: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    minLendRate: PromiseOrValue<BigNumberish>,
    blockTime: PromiseOrValue<BigNumberish>,
    useUnderlying: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, number, string] & {
      fCashAmount: BigNumber;
      marketIndex: number;
      encodedTrade: string;
    }
  >;

  getfCashNotional(
    account: PromiseOrValue<string>,
    currencyId: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  initializeMarkets(
    currencyId: PromiseOrValue<BigNumberish>,
    isFirstInit: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  initiateSecondaryBorrowSettlement(
    maturity: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isApprovedForAll(
    account: PromiseOrValue<string>,
    operator: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  liquidateCollateralCurrency(
    liquidateAccount: PromiseOrValue<string>,
    localCurrency: PromiseOrValue<BigNumberish>,
    collateralCurrency: PromiseOrValue<BigNumberish>,
    maxCollateralLiquidation: PromiseOrValue<BigNumberish>,
    maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
    withdrawCollateral: PromiseOrValue<boolean>,
    redeemToUnderlying: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  liquidateLocalCurrency(
    liquidateAccount: PromiseOrValue<string>,
    localCurrency: PromiseOrValue<BigNumberish>,
    maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  liquidatefCashCrossCurrency(
    liquidateAccount: PromiseOrValue<string>,
    localCurrency: PromiseOrValue<BigNumberish>,
    fCashCurrency: PromiseOrValue<BigNumberish>,
    fCashMaturities: PromiseOrValue<BigNumberish>[],
    maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  liquidatefCashLocal(
    liquidateAccount: PromiseOrValue<string>,
    localCurrency: PromiseOrValue<BigNumberish>,
    fCashMaturities: PromiseOrValue<BigNumberish>[],
    maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  listCurrency(
    assetToken: TokenStorageStruct,
    underlyingToken: TokenStorageStruct,
    rateOracle: PromiseOrValue<string>,
    mustInvert: PromiseOrValue<boolean>,
    buffer: PromiseOrValue<BigNumberish>,
    haircut: PromiseOrValue<BigNumberish>,
    liquidationDiscount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  nTokenAddress(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  nTokenBalanceOf(
    currencyId: PromiseOrValue<BigNumberish>,
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  nTokenClaimIncentives(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  nTokenGetClaimableIncentives(
    account: PromiseOrValue<string>,
    blockTime: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  nTokenPresentValueAssetDenominated(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  nTokenPresentValueUnderlyingDenominated(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  nTokenRedeem(
    redeemer: PromiseOrValue<string>,
    currencyId: PromiseOrValue<BigNumberish>,
    tokensToRedeem_: PromiseOrValue<BigNumberish>,
    sellTokenAssets: PromiseOrValue<boolean>,
    acceptResidualAssets: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  nTokenTotalSupply(
    nTokenAddress: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  nTokenTransfer(
    currencyId: PromiseOrValue<BigNumberish>,
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  nTokenTransferAllowance(
    currencyId: PromiseOrValue<BigNumberish>,
    owner: PromiseOrValue<string>,
    spender: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  nTokenTransferApprove(
    currencyId: PromiseOrValue<BigNumberish>,
    owner: PromiseOrValue<string>,
    spender: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  nTokenTransferApproveAll(
    spender: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  nTokenTransferFrom(
    currencyId: PromiseOrValue<BigNumberish>,
    spender: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  owner(overrides?: CallOverrides): Promise<string>;

  pauseGuardian(overrides?: CallOverrides): Promise<string>;

  pauseRouter(overrides?: CallOverrides): Promise<string>;

  redeemStrategyTokensToCash(
    maturity: PromiseOrValue<BigNumberish>,
    strategyTokensToRedeem: PromiseOrValue<BigNumberish>,
    vaultData: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  reduceMaxBorrowCapacity(
    vaultAddress: PromiseOrValue<string>,
    maxVaultBorrowCapacity: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    strategyTokensToRedeem: PromiseOrValue<BigNumberish>,
    vaultData: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  repaySecondaryCurrencyFromVault(
    account: PromiseOrValue<string>,
    currencyId: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    fCashToRepay: PromiseOrValue<BigNumberish>,
    slippageLimit: PromiseOrValue<BigNumberish>,
    callbackData: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  rollVaultPosition(
    account: PromiseOrValue<string>,
    vault: PromiseOrValue<string>,
    fCashToBorrow: PromiseOrValue<BigNumberish>,
    maturity: PromiseOrValue<BigNumberish>,
    depositAmountExternal: PromiseOrValue<BigNumberish>,
    minLendRate: PromiseOrValue<BigNumberish>,
    maxBorrowRate: PromiseOrValue<BigNumberish>,
    enterVaultData: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  safeBatchTransferFrom(
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    ids: PromiseOrValue<BigNumberish>[],
    amounts: PromiseOrValue<BigNumberish>[],
    data: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  safeTransferFrom(
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    id: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    data: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setApprovalForAll(
    operator: PromiseOrValue<string>,
    approved: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setLendingPool(
    pool: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMaxBorrowCapacity(
    vaultAddress: PromiseOrValue<string>,
    maxVaultBorrowCapacity: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setPauseRouterAndGuardian(
    pauseRouter_: PromiseOrValue<string>,
    pauseGuardian_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setReserveBuffer(
    currencyId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setReserveCashBalance(
    currencyId: PromiseOrValue<BigNumberish>,
    reserveBalance: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setSecondaryIncentiveRewarder(
    currencyId: PromiseOrValue<BigNumberish>,
    rewarder: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setTreasuryManager(
    manager: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setVaultPauseStatus(
    vaultAddress: PromiseOrValue<string>,
    enable: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  settleAccount(
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  settleVault(
    vault: PromiseOrValue<string>,
    maturity: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  signedBalanceOf(
    account: PromiseOrValue<string>,
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  signedBalanceOfBatch(
    accounts: PromiseOrValue<string>[],
    ids: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  supportsInterface(
    interfaceId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  sweepCashIntoMarkets(
    currencyId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    direct: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferReserveToTreasury(
    currencies: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateAssetRate(
    currencyId: PromiseOrValue<BigNumberish>,
    rateOracle: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateAuthorizedCallbackContract(
    operator: PromiseOrValue<string>,
    approved: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateCashGroup(
    currencyId: PromiseOrValue<BigNumberish>,
    cashGroup: CashGroupSettingsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateDepositParameters(
    currencyId: PromiseOrValue<BigNumberish>,
    depositShares: PromiseOrValue<BigNumberish>[],
    leverageThresholds: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateETHRate(
    currencyId: PromiseOrValue<BigNumberish>,
    rateOracle: PromiseOrValue<string>,
    mustInvert: PromiseOrValue<boolean>,
    buffer: PromiseOrValue<BigNumberish>,
    haircut: PromiseOrValue<BigNumberish>,
    liquidationDiscount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateGlobalTransferOperator(
    operator: PromiseOrValue<string>,
    approved: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateIncentiveEmissionRate(
    currencyId: PromiseOrValue<BigNumberish>,
    newEmissionRate: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateInitializationParameters(
    currencyId: PromiseOrValue<BigNumberish>,
    annualizedAnchorRates: PromiseOrValue<BigNumberish>[],
    proportions: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateMaxCollateralBalance(
    currencyId: PromiseOrValue<BigNumberish>,
    maxCollateralBalanceInternalPrecision: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateSecondaryBorrowCapacity(
    vaultAddress: PromiseOrValue<string>,
    secondaryCurrencyId: PromiseOrValue<BigNumberish>,
    maxBorrowCapacity: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateTokenCollateralParameters(
    currencyId: PromiseOrValue<BigNumberish>,
    residualPurchaseIncentive10BPS: PromiseOrValue<BigNumberish>,
    pvHaircutPercentage: PromiseOrValue<BigNumberish>,
    residualPurchaseTimeBufferHours: PromiseOrValue<BigNumberish>,
    cashWithholdingBuffer10BPS: PromiseOrValue<BigNumberish>,
    liquidationHaircutPercentage: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateVault(
    vaultAddress: PromiseOrValue<string>,
    vaultConfig: VaultConfigStorageStruct,
    maxPrimaryBorrowCapacity: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  upgradeTo(
    newImplementation: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  upgradeToAndCall(
    newImplementation: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdraw(
    currencyId: PromiseOrValue<BigNumberish>,
    amountInternalPrecision: PromiseOrValue<BigNumberish>,
    redeemToUnderlying: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    balanceOf(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    balanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    batchBalanceAction(
      account: PromiseOrValue<string>,
      actions: BalanceActionStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    batchBalanceAndTradeAction(
      account: PromiseOrValue<string>,
      actions: BalanceActionWithTradesStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    batchBalanceAndTradeActionWithCallback(
      account: PromiseOrValue<string>,
      actions: BalanceActionWithTradesStruct[],
      callbackData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    batchLend(
      account: PromiseOrValue<string>,
      actions: BatchLendStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    borrowSecondaryCurrencyToVault(
      account: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      fCashToBorrow: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      maxBorrowRate: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      minRollLendRate: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    calculateCollateralCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      collateralCurrency: PromiseOrValue<BigNumberish>,
      maxCollateralLiquidation: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber, BigNumber]>;

    calculateLocalCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    calculateNTokensToMint(
      currencyId: PromiseOrValue<BigNumberish>,
      amountToDepositExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    calculatefCashCrossCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[], BigNumber]>;

    calculatefCashLocalLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[], BigNumber]>;

    claimCOMPAndTransfer(
      ctokens: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimOwnership(overrides?: CallOverrides): Promise<void>;

    convertCashBalanceToExternal(
      currencyId: PromiseOrValue<BigNumberish>,
      cashBalanceInternal: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    decodeToAssets(
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<PortfolioAssetStructOutput[]>;

    deleverageAccount(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      liquidator: PromiseOrValue<string>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      transferSharesToLiquidator: PromiseOrValue<boolean>,
      redeemData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    depositAssetToken(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      amountExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    depositUnderlyingToken(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      amountExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    depositVaultCashToStrategyTokens(
      maturity: PromiseOrValue<BigNumberish>,
      assetCashToDepositExternal: PromiseOrValue<BigNumberish>,
      vaultData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    enableBitmapCurrency(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    enableCashGroup(
      currencyId: PromiseOrValue<BigNumberish>,
      assetRateOracle: PromiseOrValue<string>,
      cashGroup: CashGroupSettingsStruct,
      underlyingName: PromiseOrValue<string>,
      underlyingSymbol: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    encodeToId(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    enterVault(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      fCash: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      vaultData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    exitVault(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      vaultSharesToRedeem: PromiseOrValue<BigNumberish>,
      fCashToLend: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      exitVaultData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAccount(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        AccountContextStructOutput,
        AccountBalanceStructOutput[],
        PortfolioAssetStructOutput[]
      ] & {
        accountContext: AccountContextStructOutput;
        accountBalances: AccountBalanceStructOutput[];
        portfolio: PortfolioAssetStructOutput[];
      }
    >;

    getAccountBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        cashBalance: BigNumber;
        nTokenBalance: BigNumber;
        lastClaimTime: BigNumber;
      }
    >;

    getAccountContext(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<AccountContextStructOutput>;

    getAccountPortfolio(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PortfolioAssetStructOutput[]>;

    getActiveMarkets(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<MarketParametersStructOutput[]>;

    getActiveMarketsAtBlockTime(
      currencyId: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<MarketParametersStructOutput[]>;

    getAssetsBitmap(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    getAuthorizedCallbackContractStatus(
      callback: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getBorrowCapacity(
      vault: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        totalUsedBorrowCapacity: BigNumber;
        maxBorrowCapacity: BigNumber;
      }
    >;

    getCashAmountGivenfCashAmount(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashAmount: PromiseOrValue<BigNumberish>,
      marketIndex: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    getCashGroup(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<CashGroupSettingsStructOutput>;

    getCashGroupAndAssetRate(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [CashGroupSettingsStructOutput, AssetRateParametersStructOutput] & {
        cashGroup: CashGroupSettingsStructOutput;
        assetRate: AssetRateParametersStructOutput;
      }
    >;

    getCashRequiredToSettle(
      vault: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        assetCashRequiredToSettle: BigNumber;
        underlyingCashRequiredToSettle: BigNumber;
      }
    >;

    getCurrency(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [TokenStructOutput, TokenStructOutput] & {
        assetToken: TokenStructOutput;
        underlyingToken: TokenStructOutput;
      }
    >;

    getCurrencyAndRates(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        TokenStructOutput,
        TokenStructOutput,
        ETHRateStructOutput,
        AssetRateParametersStructOutput
      ] & {
        assetToken: TokenStructOutput;
        underlyingToken: TokenStructOutput;
        ethRate: ETHRateStructOutput;
        assetRate: AssetRateParametersStructOutput;
      }
    >;

    getCurrencyId(
      tokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<number>;

    getDepositFromfCashLend(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashAmount: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, number, string] & {
        depositAmountUnderlying: BigNumber;
        depositAmountAsset: BigNumber;
        marketIndex: number;
        encodedTrade: string;
      }
    >;

    getDepositParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber[]] & {
        depositShares: BigNumber[];
        leverageThresholds: BigNumber[];
      }
    >;

    getFreeCollateral(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber[]]>;

    getGlobalTransferOperatorStatus(
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getImplementation(overrides?: CallOverrides): Promise<string>;

    getInitializationParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber[]] & {
        annualizedAnchorRates: BigNumber[];
        proportions: BigNumber[];
      }
    >;

    getLendingPool(overrides?: CallOverrides): Promise<string>;

    getMarket(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      settlementDate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<MarketParametersStructOutput>;

    getMarketIndex(
      maturity: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<number>;

    getMaxCurrencyId(overrides?: CallOverrides): Promise<number>;

    getNTokenAccount(
      tokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        number,
        BigNumber,
        BigNumber,
        BigNumber,
        string,
        BigNumber,
        BigNumber,
        BigNumber
      ] & {
        currencyId: number;
        totalSupply: BigNumber;
        incentiveAnnualEmissionRate: BigNumber;
        lastInitializedTime: BigNumber;
        nTokenParameters: string;
        cashBalance: BigNumber;
        accumulatedNOTEPerNToken: BigNumber;
        lastAccumulatedTime: BigNumber;
      }
    >;

    getNTokenPortfolio(
      tokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [PortfolioAssetStructOutput[], PortfolioAssetStructOutput[]] & {
        liquidityTokens: PortfolioAssetStructOutput[];
        netfCashAssets: PortfolioAssetStructOutput[];
      }
    >;

    getNoteToken(overrides?: CallOverrides): Promise<string>;

    getOwnershipStatus(
      overrides?: CallOverrides
    ): Promise<[string, string] & { owner: string; pendingOwner: string }>;

    getPresentfCashValue(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      notional: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      riskAdjusted: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPrincipalFromfCashBorrow(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashBorrow: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, number, string] & {
        borrowAmountUnderlying: BigNumber;
        borrowAmountAsset: BigNumber;
        marketIndex: number;
        encodedTrade: string;
      }
    >;

    getRateStorage(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [ETHRateStorageStructOutput, AssetRateStorageStructOutput] & {
        ethRate: ETHRateStorageStructOutput;
        assetRate: AssetRateStorageStructOutput;
      }
    >;

    getReserveBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getReserveBuffer(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSecondaryBorrow(
      vault: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        totalfCashBorrowed: BigNumber;
        totalAccountDebtShares: BigNumber;
        totalfCashBorrowedInPrimarySnapshot: BigNumber;
      }
    >;

    getSecondaryIncentiveRewarder(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    getSettlementRate(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<AssetRateParametersStructOutput>;

    getTreasuryManager(overrides?: CallOverrides): Promise<string>;

    getVaultAccount(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<VaultAccountStructOutput>;

    getVaultAccountCollateralRatio(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        collateralRatio: BigNumber;
        minCollateralRatio: BigNumber;
        maxLiquidatorDepositAssetCash: BigNumber;
      }
    >;

    getVaultAccountDebtShares(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, [BigNumber, BigNumber], BigNumber] & {
        debtSharesMaturity: BigNumber;
        accountDebtShares: [BigNumber, BigNumber];
        accountStrategyTokens: BigNumber;
      }
    >;

    getVaultConfig(
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<VaultConfigStructOutput>;

    getVaultState(
      vault: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<VaultStateStructOutput>;

    getfCashAmountGivenCashAmount(
      currencyId: PromiseOrValue<BigNumberish>,
      netCashToAccount: PromiseOrValue<BigNumberish>,
      marketIndex: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getfCashBorrowFromPrincipal(
      currencyId: PromiseOrValue<BigNumberish>,
      borrowedAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, number, string] & {
        fCashDebt: BigNumber;
        marketIndex: number;
        encodedTrade: string;
      }
    >;

    getfCashLendFromDeposit(
      currencyId: PromiseOrValue<BigNumberish>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, number, string] & {
        fCashAmount: BigNumber;
        marketIndex: number;
        encodedTrade: string;
      }
    >;

    getfCashNotional(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initializeMarkets(
      currencyId: PromiseOrValue<BigNumberish>,
      isFirstInit: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    initiateSecondaryBorrowSettlement(
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    isApprovedForAll(
      account: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    liquidateCollateralCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      collateralCurrency: PromiseOrValue<BigNumberish>,
      maxCollateralLiquidation: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      withdrawCollateral: PromiseOrValue<boolean>,
      redeemToUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber, BigNumber]>;

    liquidateLocalCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    liquidatefCashCrossCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[], BigNumber]>;

    liquidatefCashLocal(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[], BigNumber]>;

    listCurrency(
      assetToken: TokenStorageStruct,
      underlyingToken: TokenStorageStruct,
      rateOracle: PromiseOrValue<string>,
      mustInvert: PromiseOrValue<boolean>,
      buffer: PromiseOrValue<BigNumberish>,
      haircut: PromiseOrValue<BigNumberish>,
      liquidationDiscount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<number>;

    nTokenAddress(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    nTokenBalanceOf(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nTokenClaimIncentives(overrides?: CallOverrides): Promise<BigNumber>;

    nTokenGetClaimableIncentives(
      account: PromiseOrValue<string>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nTokenPresentValueAssetDenominated(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nTokenPresentValueUnderlyingDenominated(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nTokenRedeem(
      redeemer: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      tokensToRedeem_: PromiseOrValue<BigNumberish>,
      sellTokenAssets: PromiseOrValue<boolean>,
      acceptResidualAssets: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nTokenTotalSupply(
      nTokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nTokenTransfer(
      currencyId: PromiseOrValue<BigNumberish>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    nTokenTransferAllowance(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nTokenTransferApprove(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    nTokenTransferApproveAll(
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    nTokenTransferFrom(
      currencyId: PromiseOrValue<BigNumberish>,
      spender: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    owner(overrides?: CallOverrides): Promise<string>;

    pauseGuardian(overrides?: CallOverrides): Promise<string>;

    pauseRouter(overrides?: CallOverrides): Promise<string>;

    redeemStrategyTokensToCash(
      maturity: PromiseOrValue<BigNumberish>,
      strategyTokensToRedeem: PromiseOrValue<BigNumberish>,
      vaultData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        assetCashRequiredToSettle: BigNumber;
        underlyingCashRequiredToSettle: BigNumber;
      }
    >;

    reduceMaxBorrowCapacity(
      vaultAddress: PromiseOrValue<string>,
      maxVaultBorrowCapacity: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      strategyTokensToRedeem: PromiseOrValue<BigNumberish>,
      vaultData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    repaySecondaryCurrencyFromVault(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      fCashToRepay: PromiseOrValue<BigNumberish>,
      slippageLimit: PromiseOrValue<BigNumberish>,
      callbackData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    rollVaultPosition(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      fCashToBorrow: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      enterVaultData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    safeBatchTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    safeTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setLendingPool(
      pool: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMaxBorrowCapacity(
      vaultAddress: PromiseOrValue<string>,
      maxVaultBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setPauseRouterAndGuardian(
      pauseRouter_: PromiseOrValue<string>,
      pauseGuardian_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setReserveBuffer(
      currencyId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setReserveCashBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      reserveBalance: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setSecondaryIncentiveRewarder(
      currencyId: PromiseOrValue<BigNumberish>,
      rewarder: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setTreasuryManager(
      manager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setVaultPauseStatus(
      vaultAddress: PromiseOrValue<string>,
      enable: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    settleAccount(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    settleVault(
      vault: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    signedBalanceOf(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    signedBalanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    sweepCashIntoMarkets(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      direct: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    transferReserveToTreasury(
      currencies: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    updateAssetRate(
      currencyId: PromiseOrValue<BigNumberish>,
      rateOracle: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateAuthorizedCallbackContract(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateCashGroup(
      currencyId: PromiseOrValue<BigNumberish>,
      cashGroup: CashGroupSettingsStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    updateDepositParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      depositShares: PromiseOrValue<BigNumberish>[],
      leverageThresholds: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    updateETHRate(
      currencyId: PromiseOrValue<BigNumberish>,
      rateOracle: PromiseOrValue<string>,
      mustInvert: PromiseOrValue<boolean>,
      buffer: PromiseOrValue<BigNumberish>,
      haircut: PromiseOrValue<BigNumberish>,
      liquidationDiscount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateGlobalTransferOperator(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateIncentiveEmissionRate(
      currencyId: PromiseOrValue<BigNumberish>,
      newEmissionRate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateInitializationParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      annualizedAnchorRates: PromiseOrValue<BigNumberish>[],
      proportions: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    updateMaxCollateralBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      maxCollateralBalanceInternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateSecondaryBorrowCapacity(
      vaultAddress: PromiseOrValue<string>,
      secondaryCurrencyId: PromiseOrValue<BigNumberish>,
      maxBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateTokenCollateralParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      residualPurchaseIncentive10BPS: PromiseOrValue<BigNumberish>,
      pvHaircutPercentage: PromiseOrValue<BigNumberish>,
      residualPurchaseTimeBufferHours: PromiseOrValue<BigNumberish>,
      cashWithholdingBuffer10BPS: PromiseOrValue<BigNumberish>,
      liquidationHaircutPercentage: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateVault(
      vaultAddress: PromiseOrValue<string>,
      vaultConfig: VaultConfigStorageStruct,
      maxPrimaryBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    withdraw(
      currencyId: PromiseOrValue<BigNumberish>,
      amountInternalPrecision: PromiseOrValue<BigNumberish>,
      redeemToUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {
    "AccountContextUpdate(address)"(
      account?: PromiseOrValue<string> | null
    ): AccountContextUpdateEventFilter;
    AccountContextUpdate(
      account?: PromiseOrValue<string> | null
    ): AccountContextUpdateEventFilter;

    "AccountSettled(address)"(
      account?: PromiseOrValue<string> | null
    ): AccountSettledEventFilter;
    AccountSettled(
      account?: PromiseOrValue<string> | null
    ): AccountSettledEventFilter;

    "AddRemoveLiquidity(address,uint16,uint40,int256,int256,int256)"(
      account?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: null,
      netAssetCash?: null,
      netfCash?: null,
      netLiquidityTokens?: null
    ): AddRemoveLiquidityEventFilter;
    AddRemoveLiquidity(
      account?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: null,
      netAssetCash?: null,
      netfCash?: null,
      netLiquidityTokens?: null
    ): AddRemoveLiquidityEventFilter;

    "Approval(address,address,uint256)"(
      owner?: PromiseOrValue<string> | null,
      spender?: PromiseOrValue<string> | null,
      amount?: null
    ): ApprovalEventFilter;
    Approval(
      owner?: PromiseOrValue<string> | null,
      spender?: PromiseOrValue<string> | null,
      amount?: null
    ): ApprovalEventFilter;

    "ApprovalForAll(address,address,bool)"(
      account?: PromiseOrValue<string> | null,
      operator?: PromiseOrValue<string> | null,
      approved?: null
    ): ApprovalForAllEventFilter;
    ApprovalForAll(
      account?: PromiseOrValue<string> | null,
      operator?: PromiseOrValue<string> | null,
      approved?: null
    ): ApprovalForAllEventFilter;

    "CashBalanceChange(address,uint16,int256)"(
      account?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      netCashChange?: null
    ): CashBalanceChangeEventFilter;
    CashBalanceChange(
      account?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      netCashChange?: null
    ): CashBalanceChangeEventFilter;

    "DeployNToken(uint16,address)"(
      currencyId?: null,
      nTokenAddress?: null
    ): DeployNTokenEventFilter;
    DeployNToken(
      currencyId?: null,
      nTokenAddress?: null
    ): DeployNTokenEventFilter;

    "ExcessReserveBalanceHarvested(uint16,int256)"(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      harvestAmount?: null
    ): ExcessReserveBalanceHarvestedEventFilter;
    ExcessReserveBalanceHarvested(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      harvestAmount?: null
    ): ExcessReserveBalanceHarvestedEventFilter;

    "IncentivesMigrated(uint16,uint256,uint256,uint256)"(
      currencyId?: null,
      migrationEmissionRate?: null,
      finalIntegralTotalSupply?: null,
      migrationTime?: null
    ): IncentivesMigratedEventFilter;
    IncentivesMigrated(
      currencyId?: null,
      migrationEmissionRate?: null,
      finalIntegralTotalSupply?: null,
      migrationTime?: null
    ): IncentivesMigratedEventFilter;

    "LendBorrowTrade(address,uint16,uint40,int256,int256)"(
      account?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: null,
      netAssetCash?: null,
      netfCash?: null
    ): LendBorrowTradeEventFilter;
    LendBorrowTrade(
      account?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: null,
      netAssetCash?: null,
      netfCash?: null
    ): LendBorrowTradeEventFilter;

    "LiquidateCollateralCurrency(address,address,uint16,uint16,int256,int256,int256)"(
      liquidated?: PromiseOrValue<string> | null,
      liquidator?: PromiseOrValue<string> | null,
      localCurrencyId?: null,
      collateralCurrencyId?: null,
      netLocalFromLiquidator?: null,
      netCollateralTransfer?: null,
      netNTokenTransfer?: null
    ): LiquidateCollateralCurrencyEventFilter;
    LiquidateCollateralCurrency(
      liquidated?: PromiseOrValue<string> | null,
      liquidator?: PromiseOrValue<string> | null,
      localCurrencyId?: null,
      collateralCurrencyId?: null,
      netLocalFromLiquidator?: null,
      netCollateralTransfer?: null,
      netNTokenTransfer?: null
    ): LiquidateCollateralCurrencyEventFilter;

    "LiquidateLocalCurrency(address,address,uint16,int256)"(
      liquidated?: PromiseOrValue<string> | null,
      liquidator?: PromiseOrValue<string> | null,
      localCurrencyId?: null,
      netLocalFromLiquidator?: null
    ): LiquidateLocalCurrencyEventFilter;
    LiquidateLocalCurrency(
      liquidated?: PromiseOrValue<string> | null,
      liquidator?: PromiseOrValue<string> | null,
      localCurrencyId?: null,
      netLocalFromLiquidator?: null
    ): LiquidateLocalCurrencyEventFilter;

    "LiquidatefCashEvent(address,address,uint16,uint16,int256,uint256[],int256[])"(
      liquidated?: PromiseOrValue<string> | null,
      liquidator?: PromiseOrValue<string> | null,
      localCurrencyId?: null,
      fCashCurrency?: null,
      netLocalFromLiquidator?: null,
      fCashMaturities?: null,
      fCashNotionalTransfer?: null
    ): LiquidatefCashEventEventFilter;
    LiquidatefCashEvent(
      liquidated?: PromiseOrValue<string> | null,
      liquidator?: PromiseOrValue<string> | null,
      localCurrencyId?: null,
      fCashCurrency?: null,
      netLocalFromLiquidator?: null,
      fCashMaturities?: null,
      fCashNotionalTransfer?: null
    ): LiquidatefCashEventEventFilter;

    "ListCurrency(uint16)"(newCurrencyId?: null): ListCurrencyEventFilter;
    ListCurrency(newCurrencyId?: null): ListCurrencyEventFilter;

    "MarketsInitialized(uint16)"(
      currencyId?: null
    ): MarketsInitializedEventFilter;
    MarketsInitialized(currencyId?: null): MarketsInitializedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "PauseRouterAndGuardianUpdated(address,address)"(
      pauseRouter?: PromiseOrValue<string> | null,
      pauseGuardian?: PromiseOrValue<string> | null
    ): PauseRouterAndGuardianUpdatedEventFilter;
    PauseRouterAndGuardianUpdated(
      pauseRouter?: PromiseOrValue<string> | null,
      pauseGuardian?: PromiseOrValue<string> | null
    ): PauseRouterAndGuardianUpdatedEventFilter;

    "ProtocolInsolvency(address,uint16,uint256,int256)"(
      vault?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      shortfall?: null
    ): ProtocolInsolvencyEventFilter;
    ProtocolInsolvency(
      vault?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      shortfall?: null
    ): ProtocolInsolvencyEventFilter;

    "ReserveBalanceUpdated(uint16,int256)"(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      newBalance?: null
    ): ReserveBalanceUpdatedEventFilter;
    ReserveBalanceUpdated(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      newBalance?: null
    ): ReserveBalanceUpdatedEventFilter;

    "ReserveBufferUpdated(uint16,uint256)"(
      currencyId?: null,
      bufferAmount?: null
    ): ReserveBufferUpdatedEventFilter;
    ReserveBufferUpdated(
      currencyId?: null,
      bufferAmount?: null
    ): ReserveBufferUpdatedEventFilter;

    "ReserveFeeAccrued(uint16,int256)"(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      fee?: null
    ): ReserveFeeAccruedEventFilter;
    ReserveFeeAccrued(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      fee?: null
    ): ReserveFeeAccruedEventFilter;

    "SetSettlementRate(uint256,uint256,uint128)"(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      rate?: null
    ): SetSettlementRateEventFilter;
    SetSettlementRate(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      rate?: null
    ): SetSettlementRateEventFilter;

    "SettledCashDebt(address,uint16,address,int256,int256)"(
      settledAccount?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      settler?: PromiseOrValue<string> | null,
      amountToSettleAsset?: null,
      fCashAmount?: null
    ): SettledCashDebtEventFilter;
    SettledCashDebt(
      settledAccount?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      settler?: PromiseOrValue<string> | null,
      amountToSettleAsset?: null,
      fCashAmount?: null
    ): SettledCashDebtEventFilter;

    "SweepCashIntoMarkets(uint16,int256)"(
      currencyId?: null,
      cashIntoMarkets?: null
    ): SweepCashIntoMarketsEventFilter;
    SweepCashIntoMarkets(
      currencyId?: null,
      cashIntoMarkets?: null
    ): SweepCashIntoMarketsEventFilter;

    "Transfer(address,address,uint256)"(
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      amount?: null
    ): TransferEventFilter;
    Transfer(
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      amount?: null
    ): TransferEventFilter;

    "TransferBatch(address,address,address,uint256[],uint256[])"(
      operator?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      ids?: null,
      values?: null
    ): TransferBatchEventFilter;
    TransferBatch(
      operator?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      ids?: null,
      values?: null
    ): TransferBatchEventFilter;

    "TransferSingle(address,address,address,uint256,uint256)"(
      operator?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      id?: null,
      value?: null
    ): TransferSingleEventFilter;
    TransferSingle(
      operator?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      id?: null,
      value?: null
    ): TransferSingleEventFilter;

    "TreasuryManagerChanged(address,address)"(
      previousManager?: PromiseOrValue<string> | null,
      newManager?: PromiseOrValue<string> | null
    ): TreasuryManagerChangedEventFilter;
    TreasuryManagerChanged(
      previousManager?: PromiseOrValue<string> | null,
      newManager?: PromiseOrValue<string> | null
    ): TreasuryManagerChangedEventFilter;

    "URI(string,uint256)"(
      value?: null,
      id?: PromiseOrValue<BigNumberish> | null
    ): URIEventFilter;
    URI(value?: null, id?: PromiseOrValue<BigNumberish> | null): URIEventFilter;

    "UpdateAssetRate(uint16)"(currencyId?: null): UpdateAssetRateEventFilter;
    UpdateAssetRate(currencyId?: null): UpdateAssetRateEventFilter;

    "UpdateAuthorizedCallbackContract(address,bool)"(
      operator?: null,
      approved?: null
    ): UpdateAuthorizedCallbackContractEventFilter;
    UpdateAuthorizedCallbackContract(
      operator?: null,
      approved?: null
    ): UpdateAuthorizedCallbackContractEventFilter;

    "UpdateCashGroup(uint16)"(currencyId?: null): UpdateCashGroupEventFilter;
    UpdateCashGroup(currencyId?: null): UpdateCashGroupEventFilter;

    "UpdateDepositParameters(uint16)"(
      currencyId?: null
    ): UpdateDepositParametersEventFilter;
    UpdateDepositParameters(
      currencyId?: null
    ): UpdateDepositParametersEventFilter;

    "UpdateETHRate(uint16)"(currencyId?: null): UpdateETHRateEventFilter;
    UpdateETHRate(currencyId?: null): UpdateETHRateEventFilter;

    "UpdateGlobalTransferOperator(address,bool)"(
      operator?: null,
      approved?: null
    ): UpdateGlobalTransferOperatorEventFilter;
    UpdateGlobalTransferOperator(
      operator?: null,
      approved?: null
    ): UpdateGlobalTransferOperatorEventFilter;

    "UpdateIncentiveEmissionRate(uint16,uint32)"(
      currencyId?: null,
      newEmissionRate?: null
    ): UpdateIncentiveEmissionRateEventFilter;
    UpdateIncentiveEmissionRate(
      currencyId?: null,
      newEmissionRate?: null
    ): UpdateIncentiveEmissionRateEventFilter;

    "UpdateInitializationParameters(uint16)"(
      currencyId?: null
    ): UpdateInitializationParametersEventFilter;
    UpdateInitializationParameters(
      currencyId?: null
    ): UpdateInitializationParametersEventFilter;

    "UpdateLendingPool(address)"(pool?: null): UpdateLendingPoolEventFilter;
    UpdateLendingPool(pool?: null): UpdateLendingPoolEventFilter;

    "UpdateMaxCollateralBalance(uint16,uint72)"(
      currencyId?: null,
      maxCollateralBalance?: null
    ): UpdateMaxCollateralBalanceEventFilter;
    UpdateMaxCollateralBalance(
      currencyId?: null,
      maxCollateralBalance?: null
    ): UpdateMaxCollateralBalanceEventFilter;

    "UpdateSecondaryIncentiveRewarder(uint16,address)"(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      rewarder?: null
    ): UpdateSecondaryIncentiveRewarderEventFilter;
    UpdateSecondaryIncentiveRewarder(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      rewarder?: null
    ): UpdateSecondaryIncentiveRewarderEventFilter;

    "UpdateTokenCollateralParameters(uint16)"(
      currencyId?: null
    ): UpdateTokenCollateralParametersEventFilter;
    UpdateTokenCollateralParameters(
      currencyId?: null
    ): UpdateTokenCollateralParametersEventFilter;

    "VaultBorrowCapacityChange(address,uint16,uint256)"(
      vault?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      totalUsedBorrowCapacity?: null
    ): VaultBorrowCapacityChangeEventFilter;
    VaultBorrowCapacityChange(
      vault?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      totalUsedBorrowCapacity?: null
    ): VaultBorrowCapacityChangeEventFilter;

    "VaultDeleverageAccount(address,address,uint256,int256)"(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      vaultSharesToLiquidator?: null,
      fCashRepaid?: null
    ): VaultDeleverageAccountEventFilter;
    VaultDeleverageAccount(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      vaultSharesToLiquidator?: null,
      fCashRepaid?: null
    ): VaultDeleverageAccountEventFilter;

    "VaultEnterMaturity(address,uint256,address,uint256,uint256,uint256)"(
      vault?: PromiseOrValue<string> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      account?: PromiseOrValue<string> | null,
      underlyingTokensTransferred?: null,
      strategyTokenDeposited?: null,
      vaultSharesMinted?: null
    ): VaultEnterMaturityEventFilter;
    VaultEnterMaturity(
      vault?: PromiseOrValue<string> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      account?: PromiseOrValue<string> | null,
      underlyingTokensTransferred?: null,
      strategyTokenDeposited?: null,
      vaultSharesMinted?: null
    ): VaultEnterMaturityEventFilter;

    "VaultEnterPosition(address,address,uint256,uint256)"(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      fCashBorrowed?: null
    ): VaultEnterPositionEventFilter;
    VaultEnterPosition(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      fCashBorrowed?: null
    ): VaultEnterPositionEventFilter;

    "VaultExitPostMaturity(address,address,uint256,uint256)"(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      underlyingToReceiver?: null
    ): VaultExitPostMaturityEventFilter;
    VaultExitPostMaturity(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      underlyingToReceiver?: null
    ): VaultExitPostMaturityEventFilter;

    "VaultExitPreMaturity(address,address,uint256,uint256,uint256,uint256)"(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      fCashToLend?: null,
      vaultSharesToRedeem?: null,
      underlyingToReceiver?: null
    ): VaultExitPreMaturityEventFilter;
    VaultExitPreMaturity(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      fCashToLend?: null,
      vaultSharesToRedeem?: null,
      underlyingToReceiver?: null
    ): VaultExitPreMaturityEventFilter;

    "VaultFeeAccrued(address,uint16,uint256,int256,int256)"(
      vault?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      reserveFee?: null,
      nTokenFee?: null
    ): VaultFeeAccruedEventFilter;
    VaultFeeAccrued(
      vault?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      reserveFee?: null,
      nTokenFee?: null
    ): VaultFeeAccruedEventFilter;

    "VaultLiquidatorProfit(address,address,address,uint256,bool)"(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      liquidator?: PromiseOrValue<string> | null,
      vaultSharesToLiquidator?: null,
      transferSharesToLiquidator?: null
    ): VaultLiquidatorProfitEventFilter;
    VaultLiquidatorProfit(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      liquidator?: PromiseOrValue<string> | null,
      vaultSharesToLiquidator?: null,
      transferSharesToLiquidator?: null
    ): VaultLiquidatorProfitEventFilter;

    "VaultMintStrategyToken(address,uint256,uint256,uint256)"(
      vault?: PromiseOrValue<string> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      assetCashDeposited?: null,
      strategyTokensMinted?: null
    ): VaultMintStrategyTokenEventFilter;
    VaultMintStrategyToken(
      vault?: PromiseOrValue<string> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      assetCashDeposited?: null,
      strategyTokensMinted?: null
    ): VaultMintStrategyTokenEventFilter;

    "VaultPauseStatus(address,bool)"(
      vault?: PromiseOrValue<string> | null,
      enabled?: null
    ): VaultPauseStatusEventFilter;
    VaultPauseStatus(
      vault?: PromiseOrValue<string> | null,
      enabled?: null
    ): VaultPauseStatusEventFilter;

    "VaultRedeemStrategyToken(address,uint256,int256,uint256)"(
      vault?: PromiseOrValue<string> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      assetCashReceived?: null,
      strategyTokensRedeemed?: null
    ): VaultRedeemStrategyTokenEventFilter;
    VaultRedeemStrategyToken(
      vault?: PromiseOrValue<string> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      assetCashReceived?: null,
      strategyTokensRedeemed?: null
    ): VaultRedeemStrategyTokenEventFilter;

    "VaultRepaySecondaryBorrow(address,address,uint16,uint256,uint256,uint256)"(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: null,
      debtSharesRepaid?: null,
      fCashLent?: null
    ): VaultRepaySecondaryBorrowEventFilter;
    VaultRepaySecondaryBorrow(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: null,
      debtSharesRepaid?: null,
      fCashLent?: null
    ): VaultRepaySecondaryBorrowEventFilter;

    "VaultRollPosition(address,address,uint256,uint256)"(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      newMaturity?: PromiseOrValue<BigNumberish> | null,
      fCashBorrowed?: null
    ): VaultRollPositionEventFilter;
    VaultRollPosition(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      newMaturity?: PromiseOrValue<BigNumberish> | null,
      fCashBorrowed?: null
    ): VaultRollPositionEventFilter;

    "VaultSecondaryBorrow(address,address,uint16,uint256,uint256,uint256)"(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: null,
      debtSharesMinted?: null,
      fCashBorrowed?: null
    ): VaultSecondaryBorrowEventFilter;
    VaultSecondaryBorrow(
      vault?: PromiseOrValue<string> | null,
      account?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: null,
      debtSharesMinted?: null,
      fCashBorrowed?: null
    ): VaultSecondaryBorrowEventFilter;

    "VaultSecondaryBorrowSnapshot(address,uint16,uint256,int256,int256)"(
      vault?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      totalfCashBorrowedInPrimarySnapshot?: null,
      exchangeRate?: null
    ): VaultSecondaryBorrowSnapshotEventFilter;
    VaultSecondaryBorrowSnapshot(
      vault?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      totalfCashBorrowedInPrimarySnapshot?: null,
      exchangeRate?: null
    ): VaultSecondaryBorrowSnapshotEventFilter;

    "VaultSettled(address,uint256,int256,uint256,uint256,uint256,int256)"(
      vault?: PromiseOrValue<string> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      totalfCash?: null,
      totalAssetCash?: null,
      totalStrategyTokens?: null,
      totalVaultShares?: null,
      strategyTokenValue?: null
    ): VaultSettledEventFilter;
    VaultSettled(
      vault?: PromiseOrValue<string> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      totalfCash?: null,
      totalAssetCash?: null,
      totalStrategyTokens?: null,
      totalVaultShares?: null,
      strategyTokenValue?: null
    ): VaultSettledEventFilter;

    "VaultSettledAssetsRemaining(address,uint256,int256,uint256)"(
      vault?: PromiseOrValue<string> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      remainingAssetCash?: null,
      remainingStrategyTokens?: null
    ): VaultSettledAssetsRemainingEventFilter;
    VaultSettledAssetsRemaining(
      vault?: PromiseOrValue<string> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      remainingAssetCash?: null,
      remainingStrategyTokens?: null
    ): VaultSettledAssetsRemainingEventFilter;

    "VaultShortfall(address,uint16,uint256,int256)"(
      vault?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      shortfall?: null
    ): VaultShortfallEventFilter;
    VaultShortfall(
      vault?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      shortfall?: null
    ): VaultShortfallEventFilter;

    "VaultStateUpdate(address,uint256,int256,uint256,uint256,uint256)"(
      vault?: PromiseOrValue<string> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      totalfCash?: null,
      totalAssetCash?: null,
      totalStrategyTokens?: null,
      totalVaultShares?: null
    ): VaultStateUpdateEventFilter;
    VaultStateUpdate(
      vault?: PromiseOrValue<string> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      totalfCash?: null,
      totalAssetCash?: null,
      totalStrategyTokens?: null,
      totalVaultShares?: null
    ): VaultStateUpdateEventFilter;

    "VaultUpdateSecondaryBorrowCapacity(address,uint16,uint80)"(
      vault?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maxSecondaryBorrowCapacity?: null
    ): VaultUpdateSecondaryBorrowCapacityEventFilter;
    VaultUpdateSecondaryBorrowCapacity(
      vault?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maxSecondaryBorrowCapacity?: null
    ): VaultUpdateSecondaryBorrowCapacityEventFilter;

    "VaultUpdated(address,bool,uint80)"(
      vault?: PromiseOrValue<string> | null,
      enabled?: null,
      maxPrimaryBorrowCapacity?: null
    ): VaultUpdatedEventFilter;
    VaultUpdated(
      vault?: PromiseOrValue<string> | null,
      enabled?: null,
      maxPrimaryBorrowCapacity?: null
    ): VaultUpdatedEventFilter;

    "nTokenResidualPurchase(uint16,uint40,address,int256,int256)"(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      purchaser?: PromiseOrValue<string> | null,
      fCashAmountToPurchase?: null,
      netAssetCashNToken?: null
    ): nTokenResidualPurchaseEventFilter;
    nTokenResidualPurchase(
      currencyId?: PromiseOrValue<BigNumberish> | null,
      maturity?: PromiseOrValue<BigNumberish> | null,
      purchaser?: PromiseOrValue<string> | null,
      fCashAmountToPurchase?: null,
      netAssetCashNToken?: null
    ): nTokenResidualPurchaseEventFilter;

    "nTokenSupplyChange(address,uint16,int256)"(
      account?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      tokenSupplyChange?: null
    ): nTokenSupplyChangeEventFilter;
    nTokenSupplyChange(
      account?: PromiseOrValue<string> | null,
      currencyId?: PromiseOrValue<BigNumberish> | null,
      tokenSupplyChange?: null
    ): nTokenSupplyChangeEventFilter;
  };

  estimateGas: {
    balanceOf(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    balanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    batchBalanceAction(
      account: PromiseOrValue<string>,
      actions: BalanceActionStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    batchBalanceAndTradeAction(
      account: PromiseOrValue<string>,
      actions: BalanceActionWithTradesStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    batchBalanceAndTradeActionWithCallback(
      account: PromiseOrValue<string>,
      actions: BalanceActionWithTradesStruct[],
      callbackData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    batchLend(
      account: PromiseOrValue<string>,
      actions: BatchLendStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    borrowSecondaryCurrencyToVault(
      account: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      fCashToBorrow: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      maxBorrowRate: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      minRollLendRate: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    calculateCollateralCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      collateralCurrency: PromiseOrValue<BigNumberish>,
      maxCollateralLiquidation: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    calculateLocalCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    calculateNTokensToMint(
      currencyId: PromiseOrValue<BigNumberish>,
      amountToDepositExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    calculatefCashCrossCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    calculatefCashLocalLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    claimCOMPAndTransfer(
      ctokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    claimOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    convertCashBalanceToExternal(
      currencyId: PromiseOrValue<BigNumberish>,
      cashBalanceInternal: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    decodeToAssets(
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    deleverageAccount(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      liquidator: PromiseOrValue<string>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      transferSharesToLiquidator: PromiseOrValue<boolean>,
      redeemData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    depositAssetToken(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      amountExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    depositUnderlyingToken(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      amountExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    depositVaultCashToStrategyTokens(
      maturity: PromiseOrValue<BigNumberish>,
      assetCashToDepositExternal: PromiseOrValue<BigNumberish>,
      vaultData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    enableBitmapCurrency(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    enableCashGroup(
      currencyId: PromiseOrValue<BigNumberish>,
      assetRateOracle: PromiseOrValue<string>,
      cashGroup: CashGroupSettingsStruct,
      underlyingName: PromiseOrValue<string>,
      underlyingSymbol: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    encodeToId(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    enterVault(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      fCash: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      vaultData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    exitVault(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      vaultSharesToRedeem: PromiseOrValue<BigNumberish>,
      fCashToLend: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      exitVaultData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getAccount(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAccountBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAccountContext(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAccountPortfolio(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getActiveMarkets(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getActiveMarketsAtBlockTime(
      currencyId: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAssetsBitmap(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAuthorizedCallbackContractStatus(
      callback: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBorrowCapacity(
      vault: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCashAmountGivenfCashAmount(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashAmount: PromiseOrValue<BigNumberish>,
      marketIndex: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCashGroup(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCashGroupAndAssetRate(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCashRequiredToSettle(
      vault: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCurrency(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCurrencyAndRates(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCurrencyId(
      tokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getDepositFromfCashLend(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashAmount: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getDepositParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getFreeCollateral(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getGlobalTransferOperatorStatus(
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getImplementation(overrides?: CallOverrides): Promise<BigNumber>;

    getInitializationParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLendingPool(overrides?: CallOverrides): Promise<BigNumber>;

    getMarket(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      settlementDate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getMarketIndex(
      maturity: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getMaxCurrencyId(overrides?: CallOverrides): Promise<BigNumber>;

    getNTokenAccount(
      tokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNTokenPortfolio(
      tokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNoteToken(overrides?: CallOverrides): Promise<BigNumber>;

    getOwnershipStatus(overrides?: CallOverrides): Promise<BigNumber>;

    getPresentfCashValue(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      notional: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      riskAdjusted: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPrincipalFromfCashBorrow(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashBorrow: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRateStorage(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getReserveBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getReserveBuffer(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSecondaryBorrow(
      vault: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSecondaryIncentiveRewarder(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSettlementRate(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTreasuryManager(overrides?: CallOverrides): Promise<BigNumber>;

    getVaultAccount(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getVaultAccountCollateralRatio(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getVaultAccountDebtShares(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getVaultConfig(
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getVaultState(
      vault: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getfCashAmountGivenCashAmount(
      currencyId: PromiseOrValue<BigNumberish>,
      netCashToAccount: PromiseOrValue<BigNumberish>,
      marketIndex: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getfCashBorrowFromPrincipal(
      currencyId: PromiseOrValue<BigNumberish>,
      borrowedAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getfCashLendFromDeposit(
      currencyId: PromiseOrValue<BigNumberish>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getfCashNotional(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initializeMarkets(
      currencyId: PromiseOrValue<BigNumberish>,
      isFirstInit: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    initiateSecondaryBorrowSettlement(
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isApprovedForAll(
      account: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    liquidateCollateralCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      collateralCurrency: PromiseOrValue<BigNumberish>,
      maxCollateralLiquidation: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      withdrawCollateral: PromiseOrValue<boolean>,
      redeemToUnderlying: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    liquidateLocalCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    liquidatefCashCrossCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    liquidatefCashLocal(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    listCurrency(
      assetToken: TokenStorageStruct,
      underlyingToken: TokenStorageStruct,
      rateOracle: PromiseOrValue<string>,
      mustInvert: PromiseOrValue<boolean>,
      buffer: PromiseOrValue<BigNumberish>,
      haircut: PromiseOrValue<BigNumberish>,
      liquidationDiscount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    nTokenAddress(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nTokenBalanceOf(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nTokenClaimIncentives(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    nTokenGetClaimableIncentives(
      account: PromiseOrValue<string>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nTokenPresentValueAssetDenominated(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nTokenPresentValueUnderlyingDenominated(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nTokenRedeem(
      redeemer: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      tokensToRedeem_: PromiseOrValue<BigNumberish>,
      sellTokenAssets: PromiseOrValue<boolean>,
      acceptResidualAssets: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    nTokenTotalSupply(
      nTokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nTokenTransfer(
      currencyId: PromiseOrValue<BigNumberish>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    nTokenTransferAllowance(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nTokenTransferApprove(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    nTokenTransferApproveAll(
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    nTokenTransferFrom(
      currencyId: PromiseOrValue<BigNumberish>,
      spender: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pauseGuardian(overrides?: CallOverrides): Promise<BigNumber>;

    pauseRouter(overrides?: CallOverrides): Promise<BigNumber>;

    redeemStrategyTokensToCash(
      maturity: PromiseOrValue<BigNumberish>,
      strategyTokensToRedeem: PromiseOrValue<BigNumberish>,
      vaultData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    reduceMaxBorrowCapacity(
      vaultAddress: PromiseOrValue<string>,
      maxVaultBorrowCapacity: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      strategyTokensToRedeem: PromiseOrValue<BigNumberish>,
      vaultData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    repaySecondaryCurrencyFromVault(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      fCashToRepay: PromiseOrValue<BigNumberish>,
      slippageLimit: PromiseOrValue<BigNumberish>,
      callbackData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    rollVaultPosition(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      fCashToBorrow: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      enterVaultData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    safeBatchTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    safeTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setLendingPool(
      pool: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMaxBorrowCapacity(
      vaultAddress: PromiseOrValue<string>,
      maxVaultBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setPauseRouterAndGuardian(
      pauseRouter_: PromiseOrValue<string>,
      pauseGuardian_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setReserveBuffer(
      currencyId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setReserveCashBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      reserveBalance: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setSecondaryIncentiveRewarder(
      currencyId: PromiseOrValue<BigNumberish>,
      rewarder: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setTreasuryManager(
      manager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setVaultPauseStatus(
      vaultAddress: PromiseOrValue<string>,
      enable: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    settleAccount(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    settleVault(
      vault: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    signedBalanceOf(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    signedBalanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    sweepCashIntoMarkets(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      direct: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferReserveToTreasury(
      currencies: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateAssetRate(
      currencyId: PromiseOrValue<BigNumberish>,
      rateOracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateAuthorizedCallbackContract(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateCashGroup(
      currencyId: PromiseOrValue<BigNumberish>,
      cashGroup: CashGroupSettingsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateDepositParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      depositShares: PromiseOrValue<BigNumberish>[],
      leverageThresholds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateETHRate(
      currencyId: PromiseOrValue<BigNumberish>,
      rateOracle: PromiseOrValue<string>,
      mustInvert: PromiseOrValue<boolean>,
      buffer: PromiseOrValue<BigNumberish>,
      haircut: PromiseOrValue<BigNumberish>,
      liquidationDiscount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateGlobalTransferOperator(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateIncentiveEmissionRate(
      currencyId: PromiseOrValue<BigNumberish>,
      newEmissionRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateInitializationParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      annualizedAnchorRates: PromiseOrValue<BigNumberish>[],
      proportions: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateMaxCollateralBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      maxCollateralBalanceInternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateSecondaryBorrowCapacity(
      vaultAddress: PromiseOrValue<string>,
      secondaryCurrencyId: PromiseOrValue<BigNumberish>,
      maxBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateTokenCollateralParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      residualPurchaseIncentive10BPS: PromiseOrValue<BigNumberish>,
      pvHaircutPercentage: PromiseOrValue<BigNumberish>,
      residualPurchaseTimeBufferHours: PromiseOrValue<BigNumberish>,
      cashWithholdingBuffer10BPS: PromiseOrValue<BigNumberish>,
      liquidationHaircutPercentage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateVault(
      vaultAddress: PromiseOrValue<string>,
      vaultConfig: VaultConfigStorageStruct,
      maxPrimaryBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdraw(
      currencyId: PromiseOrValue<BigNumberish>,
      amountInternalPrecision: PromiseOrValue<BigNumberish>,
      redeemToUnderlying: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    balanceOf(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    balanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    batchBalanceAction(
      account: PromiseOrValue<string>,
      actions: BalanceActionStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    batchBalanceAndTradeAction(
      account: PromiseOrValue<string>,
      actions: BalanceActionWithTradesStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    batchBalanceAndTradeActionWithCallback(
      account: PromiseOrValue<string>,
      actions: BalanceActionWithTradesStruct[],
      callbackData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    batchLend(
      account: PromiseOrValue<string>,
      actions: BatchLendStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    borrowSecondaryCurrencyToVault(
      account: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      fCashToBorrow: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      maxBorrowRate: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      minRollLendRate: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    calculateCollateralCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      collateralCurrency: PromiseOrValue<BigNumberish>,
      maxCollateralLiquidation: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    calculateLocalCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    calculateNTokensToMint(
      currencyId: PromiseOrValue<BigNumberish>,
      amountToDepositExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    calculatefCashCrossCurrencyLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    calculatefCashLocalLiquidation(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    claimCOMPAndTransfer(
      ctokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    claimOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    convertCashBalanceToExternal(
      currencyId: PromiseOrValue<BigNumberish>,
      cashBalanceInternal: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    decodeToAssets(
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    deleverageAccount(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      liquidator: PromiseOrValue<string>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      transferSharesToLiquidator: PromiseOrValue<boolean>,
      redeemData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    depositAssetToken(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      amountExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    depositUnderlyingToken(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      amountExternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    depositVaultCashToStrategyTokens(
      maturity: PromiseOrValue<BigNumberish>,
      assetCashToDepositExternal: PromiseOrValue<BigNumberish>,
      vaultData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    enableBitmapCurrency(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    enableCashGroup(
      currencyId: PromiseOrValue<BigNumberish>,
      assetRateOracle: PromiseOrValue<string>,
      cashGroup: CashGroupSettingsStruct,
      underlyingName: PromiseOrValue<string>,
      underlyingSymbol: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    encodeToId(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      assetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    enterVault(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      fCash: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      vaultData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    exitVault(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      vaultSharesToRedeem: PromiseOrValue<BigNumberish>,
      fCashToLend: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      exitVaultData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getAccount(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAccountBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAccountContext(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAccountPortfolio(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getActiveMarkets(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getActiveMarketsAtBlockTime(
      currencyId: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAssetsBitmap(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAuthorizedCallbackContractStatus(
      callback: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBorrowCapacity(
      vault: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCashAmountGivenfCashAmount(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashAmount: PromiseOrValue<BigNumberish>,
      marketIndex: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCashGroup(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCashGroupAndAssetRate(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCashRequiredToSettle(
      vault: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCurrency(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCurrencyAndRates(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCurrencyId(
      tokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getDepositFromfCashLend(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashAmount: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getDepositParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getFreeCollateral(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getGlobalTransferOperatorStatus(
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getImplementation(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getInitializationParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLendingPool(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getMarket(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      settlementDate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getMarketIndex(
      maturity: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getMaxCurrencyId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getNTokenAccount(
      tokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNTokenPortfolio(
      tokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNoteToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getOwnershipStatus(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPresentfCashValue(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      notional: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      riskAdjusted: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPrincipalFromfCashBorrow(
      currencyId: PromiseOrValue<BigNumberish>,
      fCashBorrow: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRateStorage(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getReserveBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getReserveBuffer(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSecondaryBorrow(
      vault: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSecondaryIncentiveRewarder(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSettlementRate(
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTreasuryManager(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getVaultAccount(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getVaultAccountCollateralRatio(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getVaultAccountDebtShares(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getVaultConfig(
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getVaultState(
      vault: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getfCashAmountGivenCashAmount(
      currencyId: PromiseOrValue<BigNumberish>,
      netCashToAccount: PromiseOrValue<BigNumberish>,
      marketIndex: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getfCashBorrowFromPrincipal(
      currencyId: PromiseOrValue<BigNumberish>,
      borrowedAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getfCashLendFromDeposit(
      currencyId: PromiseOrValue<BigNumberish>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      blockTime: PromiseOrValue<BigNumberish>,
      useUnderlying: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getfCashNotional(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initializeMarkets(
      currencyId: PromiseOrValue<BigNumberish>,
      isFirstInit: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    initiateSecondaryBorrowSettlement(
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isApprovedForAll(
      account: PromiseOrValue<string>,
      operator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    liquidateCollateralCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      collateralCurrency: PromiseOrValue<BigNumberish>,
      maxCollateralLiquidation: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      withdrawCollateral: PromiseOrValue<boolean>,
      redeemToUnderlying: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    liquidateLocalCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      maxNTokenLiquidation: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    liquidatefCashCrossCurrency(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    liquidatefCashLocal(
      liquidateAccount: PromiseOrValue<string>,
      localCurrency: PromiseOrValue<BigNumberish>,
      fCashMaturities: PromiseOrValue<BigNumberish>[],
      maxfCashLiquidateAmounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    listCurrency(
      assetToken: TokenStorageStruct,
      underlyingToken: TokenStorageStruct,
      rateOracle: PromiseOrValue<string>,
      mustInvert: PromiseOrValue<boolean>,
      buffer: PromiseOrValue<BigNumberish>,
      haircut: PromiseOrValue<BigNumberish>,
      liquidationDiscount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    nTokenAddress(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nTokenBalanceOf(
      currencyId: PromiseOrValue<BigNumberish>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nTokenClaimIncentives(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    nTokenGetClaimableIncentives(
      account: PromiseOrValue<string>,
      blockTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nTokenPresentValueAssetDenominated(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nTokenPresentValueUnderlyingDenominated(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nTokenRedeem(
      redeemer: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      tokensToRedeem_: PromiseOrValue<BigNumberish>,
      sellTokenAssets: PromiseOrValue<boolean>,
      acceptResidualAssets: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    nTokenTotalSupply(
      nTokenAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nTokenTransfer(
      currencyId: PromiseOrValue<BigNumberish>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    nTokenTransferAllowance(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nTokenTransferApprove(
      currencyId: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    nTokenTransferApproveAll(
      spender: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    nTokenTransferFrom(
      currencyId: PromiseOrValue<BigNumberish>,
      spender: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pauseGuardian(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pauseRouter(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    redeemStrategyTokensToCash(
      maturity: PromiseOrValue<BigNumberish>,
      strategyTokensToRedeem: PromiseOrValue<BigNumberish>,
      vaultData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    reduceMaxBorrowCapacity(
      vaultAddress: PromiseOrValue<string>,
      maxVaultBorrowCapacity: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      strategyTokensToRedeem: PromiseOrValue<BigNumberish>,
      vaultData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    repaySecondaryCurrencyFromVault(
      account: PromiseOrValue<string>,
      currencyId: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      fCashToRepay: PromiseOrValue<BigNumberish>,
      slippageLimit: PromiseOrValue<BigNumberish>,
      callbackData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    rollVaultPosition(
      account: PromiseOrValue<string>,
      vault: PromiseOrValue<string>,
      fCashToBorrow: PromiseOrValue<BigNumberish>,
      maturity: PromiseOrValue<BigNumberish>,
      depositAmountExternal: PromiseOrValue<BigNumberish>,
      minLendRate: PromiseOrValue<BigNumberish>,
      maxBorrowRate: PromiseOrValue<BigNumberish>,
      enterVaultData: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    safeBatchTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    safeTransferFrom(
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setApprovalForAll(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setLendingPool(
      pool: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMaxBorrowCapacity(
      vaultAddress: PromiseOrValue<string>,
      maxVaultBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setPauseRouterAndGuardian(
      pauseRouter_: PromiseOrValue<string>,
      pauseGuardian_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setReserveBuffer(
      currencyId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setReserveCashBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      reserveBalance: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setSecondaryIncentiveRewarder(
      currencyId: PromiseOrValue<BigNumberish>,
      rewarder: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setTreasuryManager(
      manager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setVaultPauseStatus(
      vaultAddress: PromiseOrValue<string>,
      enable: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    settleAccount(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    settleVault(
      vault: PromiseOrValue<string>,
      maturity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    signedBalanceOf(
      account: PromiseOrValue<string>,
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    signedBalanceOfBatch(
      accounts: PromiseOrValue<string>[],
      ids: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    sweepCashIntoMarkets(
      currencyId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      direct: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferReserveToTreasury(
      currencies: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateAssetRate(
      currencyId: PromiseOrValue<BigNumberish>,
      rateOracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateAuthorizedCallbackContract(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateCashGroup(
      currencyId: PromiseOrValue<BigNumberish>,
      cashGroup: CashGroupSettingsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateDepositParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      depositShares: PromiseOrValue<BigNumberish>[],
      leverageThresholds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateETHRate(
      currencyId: PromiseOrValue<BigNumberish>,
      rateOracle: PromiseOrValue<string>,
      mustInvert: PromiseOrValue<boolean>,
      buffer: PromiseOrValue<BigNumberish>,
      haircut: PromiseOrValue<BigNumberish>,
      liquidationDiscount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateGlobalTransferOperator(
      operator: PromiseOrValue<string>,
      approved: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateIncentiveEmissionRate(
      currencyId: PromiseOrValue<BigNumberish>,
      newEmissionRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateInitializationParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      annualizedAnchorRates: PromiseOrValue<BigNumberish>[],
      proportions: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateMaxCollateralBalance(
      currencyId: PromiseOrValue<BigNumberish>,
      maxCollateralBalanceInternalPrecision: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateSecondaryBorrowCapacity(
      vaultAddress: PromiseOrValue<string>,
      secondaryCurrencyId: PromiseOrValue<BigNumberish>,
      maxBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateTokenCollateralParameters(
      currencyId: PromiseOrValue<BigNumberish>,
      residualPurchaseIncentive10BPS: PromiseOrValue<BigNumberish>,
      pvHaircutPercentage: PromiseOrValue<BigNumberish>,
      residualPurchaseTimeBufferHours: PromiseOrValue<BigNumberish>,
      cashWithholdingBuffer10BPS: PromiseOrValue<BigNumberish>,
      liquidationHaircutPercentage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateVault(
      vaultAddress: PromiseOrValue<string>,
      vaultConfig: VaultConfigStorageStruct,
      maxPrimaryBorrowCapacity: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdraw(
      currencyId: PromiseOrValue<BigNumberish>,
      amountInternalPrecision: PromiseOrValue<BigNumberish>,
      redeemToUnderlying: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}

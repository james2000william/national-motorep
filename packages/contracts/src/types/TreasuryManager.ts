/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace IExchangeV3 {
  export type OrderStruct = {
    makerAddress: PromiseOrValue<string>;
    takerAddress: PromiseOrValue<string>;
    feeRecipientAddress: PromiseOrValue<string>;
    senderAddress: PromiseOrValue<string>;
    makerAssetAmount: PromiseOrValue<BigNumberish>;
    takerAssetAmount: PromiseOrValue<BigNumberish>;
    makerFee: PromiseOrValue<BigNumberish>;
    takerFee: PromiseOrValue<BigNumberish>;
    expirationTimeSeconds: PromiseOrValue<BigNumberish>;
    salt: PromiseOrValue<BigNumberish>;
    makerAssetData: PromiseOrValue<BytesLike>;
    takerAssetData: PromiseOrValue<BytesLike>;
    makerFeeAssetData: PromiseOrValue<BytesLike>;
    takerFeeAssetData: PromiseOrValue<BytesLike>;
  };

  export type OrderStructOutput = [
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    string,
    string,
    string
  ] & {
    makerAddress: string;
    takerAddress: string;
    feeRecipientAddress: string;
    senderAddress: string;
    makerAssetAmount: BigNumber;
    takerAssetAmount: BigNumber;
    makerFee: BigNumber;
    takerFee: BigNumber;
    expirationTimeSeconds: BigNumber;
    salt: BigNumber;
    makerAssetData: string;
    takerAssetData: string;
    makerFeeAssetData: string;
    takerFeeAssetData: string;
  };
}

export interface TreasuryManagerInterface extends utils.Interface {
  functions: {
    "ASSET_PROXY()": FunctionFragment;
    "BALANCER_POOL_TOKEN()": FunctionFragment;
    "BALANCER_VAULT()": FunctionFragment;
    "EXCHANGE()": FunctionFragment;
    "MAXIMUM_COOL_DOWN_PERIOD_SECONDS()": FunctionFragment;
    "NOTE()": FunctionFragment;
    "NOTE_ETH_POOL_ID()": FunctionFragment;
    "NOTE_INDEX()": FunctionFragment;
    "NOTIONAL()": FunctionFragment;
    "WETH()": FunctionFragment;
    "WETH_INDEX()": FunctionFragment;
    "_getNOTESpotPrice()": FunctionFragment;
    "approveBalancer()": FunctionFragment;
    "approveToken(address,uint256)": FunctionFragment;
    "cancelOrder((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes,bytes))": FunctionFragment;
    "claimOwnership()": FunctionFragment;
    "coolDownTimeInSeconds()": FunctionFragment;
    "harvestAssetsFromNotional(uint16[])": FunctionFragment;
    "harvestCOMPFromNotional(address[])": FunctionFragment;
    "initialize(address,address,uint32)": FunctionFragment;
    "investWETHAndNOTE(uint256,uint256,uint256)": FunctionFragment;
    "isValidSignature(bytes,bytes)": FunctionFragment;
    "lastInvestTimestamp()": FunctionFragment;
    "manager()": FunctionFragment;
    "notePurchaseLimit()": FunctionFragment;
    "owner()": FunctionFragment;
    "pendingOwner()": FunctionFragment;
    "priceOracles(address)": FunctionFragment;
    "proxiableUUID()": FunctionFragment;
    "sNOTE()": FunctionFragment;
    "setCoolDownTime(uint32)": FunctionFragment;
    "setManager(address)": FunctionFragment;
    "setNOTEPurchaseLimit(uint256)": FunctionFragment;
    "setPriceOracle(address,address)": FunctionFragment;
    "setSlippageLimit(address,uint256)": FunctionFragment;
    "slippageLimits(address)": FunctionFragment;
    "transferOwnership(address,bool,bool)": FunctionFragment;
    "upgradeTo(address)": FunctionFragment;
    "upgradeToAndCall(address,bytes)": FunctionFragment;
    "withdraw(address,uint256)": FunctionFragment;
    "wrapToWETH()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "ASSET_PROXY"
      | "BALANCER_POOL_TOKEN"
      | "BALANCER_VAULT"
      | "EXCHANGE"
      | "MAXIMUM_COOL_DOWN_PERIOD_SECONDS"
      | "NOTE"
      | "NOTE_ETH_POOL_ID"
      | "NOTE_INDEX"
      | "NOTIONAL"
      | "WETH"
      | "WETH_INDEX"
      | "_getNOTESpotPrice"
      | "approveBalancer"
      | "approveToken"
      | "cancelOrder"
      | "claimOwnership"
      | "coolDownTimeInSeconds"
      | "harvestAssetsFromNotional"
      | "harvestCOMPFromNotional"
      | "initialize"
      | "investWETHAndNOTE"
      | "isValidSignature"
      | "lastInvestTimestamp"
      | "manager"
      | "notePurchaseLimit"
      | "owner"
      | "pendingOwner"
      | "priceOracles"
      | "proxiableUUID"
      | "sNOTE"
      | "setCoolDownTime"
      | "setManager"
      | "setNOTEPurchaseLimit"
      | "setPriceOracle"
      | "setSlippageLimit"
      | "slippageLimits"
      | "transferOwnership"
      | "upgradeTo"
      | "upgradeToAndCall"
      | "withdraw"
      | "wrapToWETH"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "ASSET_PROXY",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "BALANCER_POOL_TOKEN",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "BALANCER_VAULT",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "EXCHANGE", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "MAXIMUM_COOL_DOWN_PERIOD_SECONDS",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "NOTE", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "NOTE_ETH_POOL_ID",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "NOTE_INDEX",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "NOTIONAL", values?: undefined): string;
  encodeFunctionData(functionFragment: "WETH", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "WETH_INDEX",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_getNOTESpotPrice",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "approveBalancer",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "approveToken",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelOrder",
    values: [IExchangeV3.OrderStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "claimOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "coolDownTimeInSeconds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "harvestAssetsFromNotional",
    values: [PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "harvestCOMPFromNotional",
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "investWETHAndNOTE",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isValidSignature",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "lastInvestTimestamp",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "manager", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "notePurchaseLimit",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "pendingOwner",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "priceOracles",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "proxiableUUID",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "sNOTE", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setCoolDownTime",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setManager",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setNOTEPurchaseLimit",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setPriceOracle",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setSlippageLimit",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "slippageLimits",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeTo",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeToAndCall",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "wrapToWETH",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "ASSET_PROXY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "BALANCER_POOL_TOKEN",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "BALANCER_VAULT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "EXCHANGE", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "MAXIMUM_COOL_DOWN_PERIOD_SECONDS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "NOTE", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "NOTE_ETH_POOL_ID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "NOTE_INDEX", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "NOTIONAL", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "WETH", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "WETH_INDEX", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "_getNOTESpotPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveBalancer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "coolDownTimeInSeconds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "harvestAssetsFromNotional",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "harvestCOMPFromNotional",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "investWETHAndNOTE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isValidSignature",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastInvestTimestamp",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "manager", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "notePurchaseLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pendingOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "priceOracles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proxiableUUID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "sNOTE", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setCoolDownTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setManager", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setNOTEPurchaseLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPriceOracle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setSlippageLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "slippageLimits",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "upgradeTo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "upgradeToAndCall",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "wrapToWETH", data: BytesLike): Result;

  events: {
    "AdminChanged(address,address)": EventFragment;
    "AssetsHarvested(uint16[],uint256[])": EventFragment;
    "AssetsInvested(uint256,uint256)": EventFragment;
    "BeaconUpgraded(address)": EventFragment;
    "COMPHarvested(address[],uint256)": EventFragment;
    "InvestmentCoolDownUpdated(uint256)": EventFragment;
    "ManagementTransferred(address,address)": EventFragment;
    "NOTEPurchaseLimitUpdated(uint256)": EventFragment;
    "OrderCancelled(uint8,bytes32,uint256)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "PriceOracleUpdated(address,address)": EventFragment;
    "SlippageLimitUpdated(address,uint256)": EventFragment;
    "Upgraded(address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AdminChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AssetsHarvested"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AssetsInvested"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BeaconUpgraded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "COMPHarvested"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "InvestmentCoolDownUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ManagementTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NOTEPurchaseLimitUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderCancelled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PriceOracleUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SlippageLimitUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Upgraded"): EventFragment;
}

export interface AdminChangedEventObject {
  previousAdmin: string;
  newAdmin: string;
}
export type AdminChangedEvent = TypedEvent<
  [string, string],
  AdminChangedEventObject
>;

export type AdminChangedEventFilter = TypedEventFilter<AdminChangedEvent>;

export interface AssetsHarvestedEventObject {
  currencies: number[];
  amounts: BigNumber[];
}
export type AssetsHarvestedEvent = TypedEvent<
  [number[], BigNumber[]],
  AssetsHarvestedEventObject
>;

export type AssetsHarvestedEventFilter = TypedEventFilter<AssetsHarvestedEvent>;

export interface AssetsInvestedEventObject {
  wethAmount: BigNumber;
  noteAmount: BigNumber;
}
export type AssetsInvestedEvent = TypedEvent<
  [BigNumber, BigNumber],
  AssetsInvestedEventObject
>;

export type AssetsInvestedEventFilter = TypedEventFilter<AssetsInvestedEvent>;

export interface BeaconUpgradedEventObject {
  beacon: string;
}
export type BeaconUpgradedEvent = TypedEvent<
  [string],
  BeaconUpgradedEventObject
>;

export type BeaconUpgradedEventFilter = TypedEventFilter<BeaconUpgradedEvent>;

export interface COMPHarvestedEventObject {
  ctokens: string[];
  amount: BigNumber;
}
export type COMPHarvestedEvent = TypedEvent<
  [string[], BigNumber],
  COMPHarvestedEventObject
>;

export type COMPHarvestedEventFilter = TypedEventFilter<COMPHarvestedEvent>;

export interface InvestmentCoolDownUpdatedEventObject {
  newCoolDownTimeSeconds: BigNumber;
}
export type InvestmentCoolDownUpdatedEvent = TypedEvent<
  [BigNumber],
  InvestmentCoolDownUpdatedEventObject
>;

export type InvestmentCoolDownUpdatedEventFilter =
  TypedEventFilter<InvestmentCoolDownUpdatedEvent>;

export interface ManagementTransferredEventObject {
  prevManager: string;
  newManager: string;
}
export type ManagementTransferredEvent = TypedEvent<
  [string, string],
  ManagementTransferredEventObject
>;

export type ManagementTransferredEventFilter =
  TypedEventFilter<ManagementTransferredEvent>;

export interface NOTEPurchaseLimitUpdatedEventObject {
  purchaseLimit: BigNumber;
}
export type NOTEPurchaseLimitUpdatedEvent = TypedEvent<
  [BigNumber],
  NOTEPurchaseLimitUpdatedEventObject
>;

export type NOTEPurchaseLimitUpdatedEventFilter =
  TypedEventFilter<NOTEPurchaseLimitUpdatedEvent>;

export interface OrderCancelledEventObject {
  orderStatus: number;
  orderHash: string;
  orderTakerAssetFilledAmount: BigNumber;
}
export type OrderCancelledEvent = TypedEvent<
  [number, string, BigNumber],
  OrderCancelledEventObject
>;

export type OrderCancelledEventFilter = TypedEventFilter<OrderCancelledEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface PriceOracleUpdatedEventObject {
  tokenAddress: string;
  oracleAddress: string;
}
export type PriceOracleUpdatedEvent = TypedEvent<
  [string, string],
  PriceOracleUpdatedEventObject
>;

export type PriceOracleUpdatedEventFilter =
  TypedEventFilter<PriceOracleUpdatedEvent>;

export interface SlippageLimitUpdatedEventObject {
  tokenAddress: string;
  slippageLimit: BigNumber;
}
export type SlippageLimitUpdatedEvent = TypedEvent<
  [string, BigNumber],
  SlippageLimitUpdatedEventObject
>;

export type SlippageLimitUpdatedEventFilter =
  TypedEventFilter<SlippageLimitUpdatedEvent>;

export interface UpgradedEventObject {
  implementation: string;
}
export type UpgradedEvent = TypedEvent<[string], UpgradedEventObject>;

export type UpgradedEventFilter = TypedEventFilter<UpgradedEvent>;

export interface TreasuryManager extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: TreasuryManagerInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    ASSET_PROXY(overrides?: CallOverrides): Promise<[string]>;

    BALANCER_POOL_TOKEN(overrides?: CallOverrides): Promise<[string]>;

    BALANCER_VAULT(overrides?: CallOverrides): Promise<[string]>;

    EXCHANGE(overrides?: CallOverrides): Promise<[string]>;

    MAXIMUM_COOL_DOWN_PERIOD_SECONDS(
      overrides?: CallOverrides
    ): Promise<[number]>;

    NOTE(overrides?: CallOverrides): Promise<[string]>;

    NOTE_ETH_POOL_ID(overrides?: CallOverrides): Promise<[string]>;

    NOTE_INDEX(overrides?: CallOverrides): Promise<[BigNumber]>;

    NOTIONAL(overrides?: CallOverrides): Promise<[string]>;

    WETH(overrides?: CallOverrides): Promise<[string]>;

    WETH_INDEX(overrides?: CallOverrides): Promise<[BigNumber]>;

    _getNOTESpotPrice(overrides?: CallOverrides): Promise<[BigNumber]>;

    approveBalancer(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    approveToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    cancelOrder(
      order: IExchangeV3.OrderStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    claimOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    coolDownTimeInSeconds(overrides?: CallOverrides): Promise<[number]>;

    harvestAssetsFromNotional(
      currencies: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    harvestCOMPFromNotional(
      ctokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    initialize(
      _owner: PromiseOrValue<string>,
      _manager: PromiseOrValue<string>,
      _coolDownTimeInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    investWETHAndNOTE(
      wethAmount: PromiseOrValue<BigNumberish>,
      noteAmount: PromiseOrValue<BigNumberish>,
      minBPT: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isValidSignature(
      data: PromiseOrValue<BytesLike>,
      signature: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    lastInvestTimestamp(overrides?: CallOverrides): Promise<[number]>;

    manager(overrides?: CallOverrides): Promise<[string]>;

    notePurchaseLimit(overrides?: CallOverrides): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pendingOwner(overrides?: CallOverrides): Promise<[string]>;

    priceOracles(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    proxiableUUID(overrides?: CallOverrides): Promise<[string]>;

    sNOTE(overrides?: CallOverrides): Promise<[string]>;

    setCoolDownTime(
      _coolDownTimeInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setManager(
      newManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setNOTEPurchaseLimit(
      purchaseLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setPriceOracle(
      tokenAddress: PromiseOrValue<string>,
      oracleAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setSlippageLimit(
      tokenAddress: PromiseOrValue<string>,
      slippageLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    slippageLimits(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      direct: PromiseOrValue<boolean>,
      renounce: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdraw(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    wrapToWETH(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  ASSET_PROXY(overrides?: CallOverrides): Promise<string>;

  BALANCER_POOL_TOKEN(overrides?: CallOverrides): Promise<string>;

  BALANCER_VAULT(overrides?: CallOverrides): Promise<string>;

  EXCHANGE(overrides?: CallOverrides): Promise<string>;

  MAXIMUM_COOL_DOWN_PERIOD_SECONDS(overrides?: CallOverrides): Promise<number>;

  NOTE(overrides?: CallOverrides): Promise<string>;

  NOTE_ETH_POOL_ID(overrides?: CallOverrides): Promise<string>;

  NOTE_INDEX(overrides?: CallOverrides): Promise<BigNumber>;

  NOTIONAL(overrides?: CallOverrides): Promise<string>;

  WETH(overrides?: CallOverrides): Promise<string>;

  WETH_INDEX(overrides?: CallOverrides): Promise<BigNumber>;

  _getNOTESpotPrice(overrides?: CallOverrides): Promise<BigNumber>;

  approveBalancer(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  approveToken(
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  cancelOrder(
    order: IExchangeV3.OrderStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  claimOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  coolDownTimeInSeconds(overrides?: CallOverrides): Promise<number>;

  harvestAssetsFromNotional(
    currencies: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  harvestCOMPFromNotional(
    ctokens: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  initialize(
    _owner: PromiseOrValue<string>,
    _manager: PromiseOrValue<string>,
    _coolDownTimeInSeconds: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  investWETHAndNOTE(
    wethAmount: PromiseOrValue<BigNumberish>,
    noteAmount: PromiseOrValue<BigNumberish>,
    minBPT: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isValidSignature(
    data: PromiseOrValue<BytesLike>,
    signature: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  lastInvestTimestamp(overrides?: CallOverrides): Promise<number>;

  manager(overrides?: CallOverrides): Promise<string>;

  notePurchaseLimit(overrides?: CallOverrides): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  pendingOwner(overrides?: CallOverrides): Promise<string>;

  priceOracles(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  proxiableUUID(overrides?: CallOverrides): Promise<string>;

  sNOTE(overrides?: CallOverrides): Promise<string>;

  setCoolDownTime(
    _coolDownTimeInSeconds: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setManager(
    newManager: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setNOTEPurchaseLimit(
    purchaseLimit: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setPriceOracle(
    tokenAddress: PromiseOrValue<string>,
    oracleAddress: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setSlippageLimit(
    tokenAddress: PromiseOrValue<string>,
    slippageLimit: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  slippageLimits(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    direct: PromiseOrValue<boolean>,
    renounce: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  upgradeTo(
    newImplementation: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  upgradeToAndCall(
    newImplementation: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdraw(
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  wrapToWETH(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    ASSET_PROXY(overrides?: CallOverrides): Promise<string>;

    BALANCER_POOL_TOKEN(overrides?: CallOverrides): Promise<string>;

    BALANCER_VAULT(overrides?: CallOverrides): Promise<string>;

    EXCHANGE(overrides?: CallOverrides): Promise<string>;

    MAXIMUM_COOL_DOWN_PERIOD_SECONDS(
      overrides?: CallOverrides
    ): Promise<number>;

    NOTE(overrides?: CallOverrides): Promise<string>;

    NOTE_ETH_POOL_ID(overrides?: CallOverrides): Promise<string>;

    NOTE_INDEX(overrides?: CallOverrides): Promise<BigNumber>;

    NOTIONAL(overrides?: CallOverrides): Promise<string>;

    WETH(overrides?: CallOverrides): Promise<string>;

    WETH_INDEX(overrides?: CallOverrides): Promise<BigNumber>;

    _getNOTESpotPrice(overrides?: CallOverrides): Promise<BigNumber>;

    approveBalancer(overrides?: CallOverrides): Promise<void>;

    approveToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    cancelOrder(
      order: IExchangeV3.OrderStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    claimOwnership(overrides?: CallOverrides): Promise<void>;

    coolDownTimeInSeconds(overrides?: CallOverrides): Promise<number>;

    harvestAssetsFromNotional(
      currencies: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    harvestCOMPFromNotional(
      ctokens: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    initialize(
      _owner: PromiseOrValue<string>,
      _manager: PromiseOrValue<string>,
      _coolDownTimeInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    investWETHAndNOTE(
      wethAmount: PromiseOrValue<BigNumberish>,
      noteAmount: PromiseOrValue<BigNumberish>,
      minBPT: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    isValidSignature(
      data: PromiseOrValue<BytesLike>,
      signature: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    lastInvestTimestamp(overrides?: CallOverrides): Promise<number>;

    manager(overrides?: CallOverrides): Promise<string>;

    notePurchaseLimit(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    pendingOwner(overrides?: CallOverrides): Promise<string>;

    priceOracles(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    proxiableUUID(overrides?: CallOverrides): Promise<string>;

    sNOTE(overrides?: CallOverrides): Promise<string>;

    setCoolDownTime(
      _coolDownTimeInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setManager(
      newManager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setNOTEPurchaseLimit(
      purchaseLimit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setPriceOracle(
      tokenAddress: PromiseOrValue<string>,
      oracleAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setSlippageLimit(
      tokenAddress: PromiseOrValue<string>,
      slippageLimit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    slippageLimits(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      direct: PromiseOrValue<boolean>,
      renounce: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    withdraw(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    wrapToWETH(overrides?: CallOverrides): Promise<void>;
  };

  filters: {
    "AdminChanged(address,address)"(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;
    AdminChanged(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;

    "AssetsHarvested(uint16[],uint256[])"(
      currencies?: null,
      amounts?: null
    ): AssetsHarvestedEventFilter;
    AssetsHarvested(
      currencies?: null,
      amounts?: null
    ): AssetsHarvestedEventFilter;

    "AssetsInvested(uint256,uint256)"(
      wethAmount?: null,
      noteAmount?: null
    ): AssetsInvestedEventFilter;
    AssetsInvested(
      wethAmount?: null,
      noteAmount?: null
    ): AssetsInvestedEventFilter;

    "BeaconUpgraded(address)"(
      beacon?: PromiseOrValue<string> | null
    ): BeaconUpgradedEventFilter;
    BeaconUpgraded(
      beacon?: PromiseOrValue<string> | null
    ): BeaconUpgradedEventFilter;

    "COMPHarvested(address[],uint256)"(
      ctokens?: null,
      amount?: null
    ): COMPHarvestedEventFilter;
    COMPHarvested(ctokens?: null, amount?: null): COMPHarvestedEventFilter;

    "InvestmentCoolDownUpdated(uint256)"(
      newCoolDownTimeSeconds?: null
    ): InvestmentCoolDownUpdatedEventFilter;
    InvestmentCoolDownUpdated(
      newCoolDownTimeSeconds?: null
    ): InvestmentCoolDownUpdatedEventFilter;

    "ManagementTransferred(address,address)"(
      prevManager?: null,
      newManager?: null
    ): ManagementTransferredEventFilter;
    ManagementTransferred(
      prevManager?: null,
      newManager?: null
    ): ManagementTransferredEventFilter;

    "NOTEPurchaseLimitUpdated(uint256)"(
      purchaseLimit?: null
    ): NOTEPurchaseLimitUpdatedEventFilter;
    NOTEPurchaseLimitUpdated(
      purchaseLimit?: null
    ): NOTEPurchaseLimitUpdatedEventFilter;

    "OrderCancelled(uint8,bytes32,uint256)"(
      orderStatus?: null,
      orderHash?: null,
      orderTakerAssetFilledAmount?: null
    ): OrderCancelledEventFilter;
    OrderCancelled(
      orderStatus?: null,
      orderHash?: null,
      orderTakerAssetFilledAmount?: null
    ): OrderCancelledEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "PriceOracleUpdated(address,address)"(
      tokenAddress?: null,
      oracleAddress?: null
    ): PriceOracleUpdatedEventFilter;
    PriceOracleUpdated(
      tokenAddress?: null,
      oracleAddress?: null
    ): PriceOracleUpdatedEventFilter;

    "SlippageLimitUpdated(address,uint256)"(
      tokenAddress?: null,
      slippageLimit?: null
    ): SlippageLimitUpdatedEventFilter;
    SlippageLimitUpdated(
      tokenAddress?: null,
      slippageLimit?: null
    ): SlippageLimitUpdatedEventFilter;

    "Upgraded(address)"(
      implementation?: PromiseOrValue<string> | null
    ): UpgradedEventFilter;
    Upgraded(
      implementation?: PromiseOrValue<string> | null
    ): UpgradedEventFilter;
  };

  estimateGas: {
    ASSET_PROXY(overrides?: CallOverrides): Promise<BigNumber>;

    BALANCER_POOL_TOKEN(overrides?: CallOverrides): Promise<BigNumber>;

    BALANCER_VAULT(overrides?: CallOverrides): Promise<BigNumber>;

    EXCHANGE(overrides?: CallOverrides): Promise<BigNumber>;

    MAXIMUM_COOL_DOWN_PERIOD_SECONDS(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    NOTE(overrides?: CallOverrides): Promise<BigNumber>;

    NOTE_ETH_POOL_ID(overrides?: CallOverrides): Promise<BigNumber>;

    NOTE_INDEX(overrides?: CallOverrides): Promise<BigNumber>;

    NOTIONAL(overrides?: CallOverrides): Promise<BigNumber>;

    WETH(overrides?: CallOverrides): Promise<BigNumber>;

    WETH_INDEX(overrides?: CallOverrides): Promise<BigNumber>;

    _getNOTESpotPrice(overrides?: CallOverrides): Promise<BigNumber>;

    approveBalancer(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    approveToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    cancelOrder(
      order: IExchangeV3.OrderStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    claimOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    coolDownTimeInSeconds(overrides?: CallOverrides): Promise<BigNumber>;

    harvestAssetsFromNotional(
      currencies: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    harvestCOMPFromNotional(
      ctokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    initialize(
      _owner: PromiseOrValue<string>,
      _manager: PromiseOrValue<string>,
      _coolDownTimeInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    investWETHAndNOTE(
      wethAmount: PromiseOrValue<BigNumberish>,
      noteAmount: PromiseOrValue<BigNumberish>,
      minBPT: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isValidSignature(
      data: PromiseOrValue<BytesLike>,
      signature: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    lastInvestTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    manager(overrides?: CallOverrides): Promise<BigNumber>;

    notePurchaseLimit(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pendingOwner(overrides?: CallOverrides): Promise<BigNumber>;

    priceOracles(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    proxiableUUID(overrides?: CallOverrides): Promise<BigNumber>;

    sNOTE(overrides?: CallOverrides): Promise<BigNumber>;

    setCoolDownTime(
      _coolDownTimeInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setManager(
      newManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setNOTEPurchaseLimit(
      purchaseLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setPriceOracle(
      tokenAddress: PromiseOrValue<string>,
      oracleAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setSlippageLimit(
      tokenAddress: PromiseOrValue<string>,
      slippageLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    slippageLimits(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      direct: PromiseOrValue<boolean>,
      renounce: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdraw(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    wrapToWETH(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    ASSET_PROXY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    BALANCER_POOL_TOKEN(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    BALANCER_VAULT(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    EXCHANGE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MAXIMUM_COOL_DOWN_PERIOD_SECONDS(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    NOTE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    NOTE_ETH_POOL_ID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    NOTE_INDEX(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    NOTIONAL(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    WETH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    WETH_INDEX(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    _getNOTESpotPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    approveBalancer(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    approveToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    cancelOrder(
      order: IExchangeV3.OrderStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    claimOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    coolDownTimeInSeconds(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    harvestAssetsFromNotional(
      currencies: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    harvestCOMPFromNotional(
      ctokens: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    initialize(
      _owner: PromiseOrValue<string>,
      _manager: PromiseOrValue<string>,
      _coolDownTimeInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    investWETHAndNOTE(
      wethAmount: PromiseOrValue<BigNumberish>,
      noteAmount: PromiseOrValue<BigNumberish>,
      minBPT: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isValidSignature(
      data: PromiseOrValue<BytesLike>,
      signature: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lastInvestTimestamp(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    manager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    notePurchaseLimit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    priceOracles(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    proxiableUUID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    sNOTE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setCoolDownTime(
      _coolDownTimeInSeconds: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setManager(
      newManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setNOTEPurchaseLimit(
      purchaseLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setPriceOracle(
      tokenAddress: PromiseOrValue<string>,
      oracleAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setSlippageLimit(
      tokenAddress: PromiseOrValue<string>,
      slippageLimit: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    slippageLimits(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      direct: PromiseOrValue<boolean>,
      renounce: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdraw(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    wrapToWETH(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
